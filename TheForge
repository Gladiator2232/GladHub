--[[
    Glad Hub | The Forge | V7.7 SMART FARMING EDITION
    
    V7.7 SMART SOURCE FARMING:
    ========================
    - Select ORES you want (Gold, Diamond, etc.)
    - System calculates SOURCE ROCKS to mine (Boulder, Basalt Vein, etc.)
    - Auto Mine targets SOURCE ROCKS, you get the ORE DROPS!
    - Shows "WILL MINE:" panel with calculated sources
    - OreDatabase now includes Sources field
    
    MANAGERS:
    ========================
    - SELL MANAGER - Toggle which ores to sell
    - ORE MANAGER - Select ores > Auto-calculates source rocks
    - MONSTER MANAGER - Toggle which monsters to farm
    - Real icons from game Index
    - No emojis - uses Roblox image IDs
    - Protected ores OFF by default
]]

--!native
--!optimize 2

--// ============================================================
--// SERVICES
--// ============================================================

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local GuiService = game:GetService("GuiService")

--// ============================================================
--// DEVICE DETECTION
--// ============================================================

local IsMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
local IsTablet = UserInputService.TouchEnabled and (Workspace.CurrentCamera.ViewportSize.X > 1000)
local ScreenSize = Workspace.CurrentCamera.ViewportSize

--// ============================================================
--// TYPE DEFINITIONS
--// ============================================================

type Connection = RBXScriptConnection
type Signal<T...> = {
    Connect: (self: Signal<T...>, callback: (T...) -> ()) -> Connection,
    Fire: (self: Signal<T...>, T...) -> (),
    Wait: (self: Signal<T...>) -> T...,
    Destroy: (self: Signal<T...>) -> (),
}

type Spring = {
    Position: Vector3 | number,
    Velocity: Vector3 | number,
    Target: Vector3 | number,
    Damping: number,
    Speed: number,
    Update: (self: Spring, dt: number) -> Vector3 | number,
}

type FarmConfig = {
    StateKey: string,
    FindTarget: () -> (Instance?, number?),
    GetTargetPosition: (target: Instance) -> Vector3?,
    IsTargetValid: (target: Instance) -> boolean,
    PerformAction: (target: Instance) -> (),
    GetActionDistance: () -> number,
    OnTargetReached: ((target: Instance) -> ())?,
    OnTargetLost: ((target: Instance) -> ())?,
}

--// ============================================================
--// PLAYER REFERENCES
--// ============================================================

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

--// ============================================================
--// ICON ASSETS
--// ============================================================

local Icons = {
    Auto = "rbxassetid://9791996819",
    ESP = "rbxassetid://15728390008",
    Settings = "rbxassetid://4738901432",
    Misc = "rbxassetid://110860790268834",
    Mine = "rbxassetid://86209316336347",
    Kill = "rbxassetid://745674104",
    Toggle = "rbxassetid://103724393619811",
}

--// ============================================================
--// RESPONSIVE SIZES
--// ============================================================

local UIScale = IsMobile and 0.75 or 1
local MainFrameSize = IsMobile and UDim2.new(0, 380, 0, 350) or UDim2.new(0, 500, 0, 420)
local MainFrameMinimizedSize = IsMobile and UDim2.new(0, 380, 0, 40) or UDim2.new(0, 500, 0, 45)
local ToggleButtonSize = IsMobile and UDim2.new(0, 50, 0, 50) or UDim2.new(0, 55, 0, 55)
local SidebarWidth = IsMobile and 55 or 70
local FontSizeMultiplier = IsMobile and 0.85 or 1

--// ============================================================
--// CONFIGURATION
--// ============================================================

local Config = {
    -- Auto Farm
    SelectedOres = {} :: {string},      -- Ores user wants to obtain
    SelectedSources = {} :: {string},   -- Source rocks to mine (calculated from SelectedOres)
    MineDistance = 4,
    CruiseHeight = 150,
    MoveSpeed = 75,
    
    -- Kill Nearby Enemy (while mining)
    KillNearbyEnabled = false,
    KillNearbyRange = 30,
    
    -- Avoid Player
    AvoidPlayerEnabled = false,
    AvoidPlayerDistance = 100,
    
    -- Auto Kill
    SelectedMonsters = {} :: {string},
    KillDistance = 7,
    
    -- Auto Sell (Continuous selling)
    AutoSellEnabled = false,
    AutoSellInterval = 1,
    
    -- Anti-TP (Anti-Cheat Bypass)
    AntiTpEnabled = true,
    AntiTpThreshold = 50,
    AntiTpCooldown = 2,
    AntiTpMaxStrikes = 3,
    AntiTpLongPause = 5,
    
    -- Goblin Cave Avoidance
    AvoidGoblinCave = true,
    GoblinCaveBuffer = 15,
    GoblinCaveRiseHeight = 200,
    
    -- Blacklisted Maps
    BlacklistedMaps = {"Island2GoblinCave"},
    
    -- ESP
    EspPlayersEnabled = false,
    EspMonstersEnabled = false,
    EspOresEnabled = false,
    EspDistance = 500,
    
    -- Misc
    CustomWalkSpeed = 16,
    WalkSpeedEnabled = false,
    FullbrightEnabled = false,
    AutoRunEnabled = false,
    
    -- Spring Physics Settings
    MovementDamping = 8,
    MovementSpeed = 25,
    RotationResponsiveness = 50,
}

--// ============================================================
--// AUTO SELL CONFIGURATION (V7.7 - ENHANCED WITH ORE SELECTION)
--// ============================================================

local AutoSellConfig = {
    -- Complete list of UI class names to skip
    UIClassNames = {
        -- UI Layout
        "UIListLayout", "UIPadding", "UIGridLayout", "UICorner", "UIStroke",
        "UIAspectRatioConstraint", "UIGradient", "UIScale", "UISizeConstraint",
        "UITextSizeConstraint", "UIPageLayout", "UITableLayout", "UIFlexItem",
        -- GUI Elements (these can appear as child names)
        "Frame", "ScrollingFrame", "TextLabel", "TextButton", "ImageLabel",
        "ImageButton", "TextBox", "ViewportFrame", "BillboardGui", "SurfaceGui",
        "ScreenGui", "CanvasGroup", "VideoFrame",
    },
    -- Protected items that should never be sold (tools, totems)
    ProtectedItems = {
        -- Luck Totems (various name formats)
        "LuckTotem1", "LuckTotem2", "LuckTotem3",
        "Luck Totem I", "Luck Totem II", "Luck Totem III",
        "Luck Totem 1", "Luck Totem 2", "Luck Totem 3",
        -- Portal tool
        "PortalTool", "Portal",
        -- Internal/Template items
        "Template", "Placeholder", "Empty",
    },
    -- Pattern matching for additional filtering
    UIPatterns = {
        "^UI",           -- Starts with UI
        "Layout$",       -- Ends with Layout
        "Constraint$",   -- Ends with Constraint
        "^_",            -- Starts with underscore (internal)
        "Template$",     -- Ends with Template
    },
    SellInterval = 1,
    MinItemsToSell = 1,
    MaxRetries = 3,
}

--// ============================================================
--// ORE DATABASE (Wiki Accurate - All Ores)
--// ============================================================

local OreDatabase = {
    -- COMMON
    {Name = "Stone", Rarity = "Common", Chance = "1/1", Price = 3, Multiplier = "0.2x", Trait = "None", Sources = {"Pebble"}},
    {Name = "Sand Stone", Rarity = "Common", Chance = "1/2", Price = 3.75, Multiplier = "0.25x", Trait = "None", Sources = {"Pebble", "Rock"}},
    {Name = "Copper", Rarity = "Common", Chance = "1/3", Price = 4.5, Multiplier = "0.3x", Trait = "None", Sources = {"Pebble", "Rock", "Boulder"}},
    {Name = "Iron", Rarity = "Common", Chance = "1/5", Price = 5.25, Multiplier = "0.35x", Trait = "None", Sources = {"Pebble", "Rock", "Boulder"}},
    {Name = "Cardboardite", Rarity = "Common", Chance = "1/31", Price = 10.5, Multiplier = "0.7x", Trait = "None", Sources = {"Rock", "Boulder"}},
    
    -- UNCOMMON
    {Name = "Tin", Rarity = "Uncommon", Chance = "1/7", Price = 6.38, Multiplier = "0.425x", Trait = "None", Sources = {"Rock", "Boulder"}},
    {Name = "Silver", Rarity = "Uncommon", Chance = "1/12", Price = 7.5, Multiplier = "0.5x", Trait = "None", Sources = {"Rock", "Boulder"}},
    {Name = "Gold", Rarity = "Uncommon", Chance = "1/16", Price = 19.5, Multiplier = "0.65x", Trait = "None", Sources = {"Boulder"}},
    {Name = "Bananite", Rarity = "Uncommon", Chance = "1/30", Price = 12.75, Multiplier = "0.85x", Trait = "None", Sources = {"Rock", "Boulder"}},
    {Name = "Cobalt", Rarity = "Uncommon", Chance = "1/37", Price = 15, Multiplier = "1x", Trait = "None", Sources = {"Basalt Rock", "Basalt Core"}},
    {Name = "Titanium", Rarity = "Uncommon", Chance = "1/50", Price = 17.25, Multiplier = "1.15x", Trait = "None", Sources = {"Basalt Rock", "Basalt Core"}},
    {Name = "Lapis Lazuli", Rarity = "Uncommon", Chance = "1/73", Price = 22.5, Multiplier = "1.3x", Trait = "None", Sources = {"Basalt Core", "Basalt Rock"}},
    
    -- RARE
    {Name = "Mushroomite", Rarity = "Rare", Chance = "1/22", Price = 12, Multiplier = "0.8x", Trait = "None", Sources = {"Rock", "Boulder"}},
    {Name = "Platinum", Rarity = "Rare", Chance = "1/28", Price = 12, Multiplier = "0.8x", Trait = "None", Sources = {"Boulder"}},
    {Name = "Volcanic Rock", Rarity = "Rare", Chance = "1/55", Price = 23.25, Multiplier = "1.55x", Trait = "None", Sources = {"Volcanic Rock"}},
    {Name = "Quartz", Rarity = "Rare", Chance = "1/90", Price = 22.5, Multiplier = "1.5x", Trait = "None", Sources = {"Basalt Core", "Basalt Vein"}},
    {Name = "Amethyst", Rarity = "Rare", Chance = "1/115", Price = 24.75, Multiplier = "1.65x", Trait = "None", Sources = {"Basalt Core", "Basalt Vein"}},
    {Name = "Topaz", Rarity = "Rare", Chance = "1/143", Price = 26.25, Multiplier = "1.75x", Trait = "None", Sources = {"Basalt Core", "Basalt Vein", "Volcanic Rock"}},
    {Name = "Diamond", Rarity = "Rare", Chance = "1/192", Price = 30, Multiplier = "2x", Trait = "None", Sources = {"Basalt Core", "Basalt Vein"}},
    {Name = "Boneite", Rarity = "Rare", Chance = "1/222", Price = 18, Multiplier = "1.2x", Trait = "None", Sources = {"Bomber", "Skeleton Rogue", "Axe Skeleton", "Deathaxe Skeleton"}},
    {Name = "Sapphire", Rarity = "Rare", Chance = "1/247", Price = 33.75, Multiplier = "2.25x", Trait = "None", Sources = {"Basalt Core", "Basalt Vein"}},
    {Name = "Dark Boneite", Rarity = "Rare", Chance = "1/555", Price = 33.75, Multiplier = "2.25x", Trait = "None", Sources = {"Elite Skeleton Rogue", "Elite Deathaxe Skeleton", "Blight Pyromancer", "Reaper"}},
    
    -- EPIC
    {Name = "Aite", Rarity = "Epic", Chance = "1/44", Price = 16.5, Multiplier = "1x", Trait = "None", Sources = {"Boulder"}},
    {Name = "Poopite", Rarity = "Epic", Chance = "1/131", Price = 18, Multiplier = "1.2x", Trait = "15% poison", Sources = {"Pebble", "Rock", "Boulder"}},
    {Name = "Slimite", Rarity = "Epic", Chance = "1/247", Price = 33.75, Multiplier = "2.25x", Trait = "None", Sources = {"Slime", "Blazing Slime"}},
    {Name = "Orange Crystal Ore", Rarity = "Epic", Chance = "1/255", Price = 45, Multiplier = "3x", Trait = "None", Sources = {"Crimson Crystal", "Cyan Crystal", "Earth Crystal", "Light Crystal"}},
    {Name = "Magenta Crystal Ore", Rarity = "Epic", Chance = "1/255", Price = 46.5, Multiplier = "3.1x", Trait = "None", Sources = {"Crimson Crystal", "Cyan Crystal", "Earth Crystal", "Light Crystal"}},
    {Name = "Green Crystal Ore", Rarity = "Epic", Chance = "1/255", Price = 48, Multiplier = "3.2x", Trait = "None", Sources = {"Crimson Crystal", "Cyan Crystal", "Earth Crystal", "Light Crystal"}},
    {Name = "Crimson Crystal Ore", Rarity = "Epic", Chance = "1/255", Price = 49.5, Multiplier = "3.3x", Trait = "None", Sources = {"Crimson Crystal", "Cyan Crystal", "Earth Crystal", "Light Crystal"}},
    {Name = "Blue Crystal Ore", Rarity = "Epic", Chance = "1/255", Price = 51, Multiplier = "3.4x", Trait = "None", Sources = {"Crimson Crystal", "Cyan Crystal", "Earth Crystal", "Light Crystal"}},
    {Name = "Cuprite", Rarity = "Epic", Chance = "1/303", Price = 36.45, Multiplier = "2.43x", Trait = "None", Sources = {"Basalt Core", "Basalt Vein", "Volcanic Rock"}},
    {Name = "Obsidian", Rarity = "Epic", Chance = "1/333", Price = 35.25, Multiplier = "2.35x", Trait = "30% defense", Sources = {"Volcanic Rock"}},
    {Name = "Emerald", Rarity = "Epic", Chance = "1/363", Price = 38.25, Multiplier = "2.55x", Trait = "None", Sources = {"Basalt Core", "Basalt Vein"}},
    {Name = "Ruby", Rarity = "Epic", Chance = "1/487", Price = 44.25, Multiplier = "2.95x", Trait = "None", Sources = {"Basalt Vein"}},
    {Name = "Rivalite", Rarity = "Epic", Chance = "1/569", Price = 49.95, Multiplier = "3.33x", Trait = "+20% crit", Sources = {"Basalt Vein", "Volcanic Rock"}},
    
    -- LEGENDARY
    {Name = "Uranium", Rarity = "Legendary", Chance = "1/777", Price = 66, Multiplier = "3x", Trait = "5% AOE dmg", Sources = {"Basalt Vein"}},
    {Name = "Mythril", Rarity = "Legendary", Chance = "1/813", Price = 52.5, Multiplier = "3.5x", Trait = "15% defense", Sources = {"Basalt Vein"}},
    {Name = "Eye Ore", Rarity = "Legendary", Chance = "1/1333", Price = 37.5, Multiplier = "4x", Trait = "-10% HP, +15% dmg", Sources = {"Basalt Rock", "Basalt Core", "Basalt Vein", "Volcanic Rock"}},
    {Name = "Fireite", Rarity = "Legendary", Chance = "1/2187", Price = 67.5, Multiplier = "4.5x", Trait = "20% burn", Sources = {"Volcanic Rock"}},
    {Name = "Magmaite", Rarity = "Legendary", Chance = "1/3003", Price = 75, Multiplier = "5x", Trait = "50% AOE", Sources = {"Volcanic Rock"}},
    {Name = "Lightite", Rarity = "Legendary", Chance = "1/3333", Price = 69, Multiplier = "4.6x", Trait = "15% speed", Sources = {"Basalt Vein"}},
    {Name = "Rainbow Crystal Ore", Rarity = "Legendary", Chance = "1/5000", Price = 78.75, Multiplier = "5.25x", Trait = "None", Sources = {"Crimson Crystal", "Cyan Crystal", "Earth Crystal", "Light Crystal"}},
    
    -- MYTHICAL
    {Name = "Demonite", Rarity = "Mythical", Chance = "1/3666", Price = 82.5, Multiplier = "5.5x", Trait = "25% Burn", Sources = {"Volcanic Rock"}},
    {Name = "Darkryte", Rarity = "Mythical", Chance = "1/6655", Price = 94.5, Multiplier = "6.3x", Trait = "15% Dodge", Sources = {"Volcanic Rock"}},
    {Name = "Arcane Crystal Ore", Rarity = "Mythical", Chance = "1/100000", Price = 112.5, Multiplier = "7.5x", Trait = "None", Sources = {"Crimson Crystal", "Cyan Crystal", "Earth Crystal", "Light Crystal"}},
    
    -- DIVINE
    {Name = "Galaxite", Rarity = "Divine", Chance = "1/1M", Price = 0, Multiplier = "11.5x", Trait = "Unobtainable", Sources = {}},
    
    -- RELIC
    {Name = "Fichillium", Rarity = "Relic", Chance = "1/1", Price = 0, Multiplier = "0x", Trait = "Lucky Block Only", Sources = {"Lucky Block"}},
    
    -- ESSENCES (Common drops, always sellable)
    {Name = "Tiny Essence", Rarity = "Common", Chance = "1/1", Price = 1, Multiplier = "0.1x", Trait = "None", Sources = {"All"}},
    {Name = "Small Essence", Rarity = "Common", Chance = "1/2", Price = 2, Multiplier = "0.2x", Trait = "None", Sources = {"All"}},
    {Name = "Medium Essence", Rarity = "Uncommon", Chance = "1/5", Price = 5, Multiplier = "0.5x", Trait = "None", Sources = {"All"}},
    {Name = "Large Essence", Rarity = "Rare", Chance = "1/10", Price = 10, Multiplier = "1x", Trait = "None", Sources = {"All"}},
}

-- All possible source rocks (for reference)
local AllSourceRocks = {
    -- Basic rocks
    "Pebble", "Rock", "Boulder",
    -- Basalt rocks
    "Basalt Rock", "Basalt Core", "Basalt Vein",
    -- Volcanic
    "Volcanic Rock",
    -- Crystals
    "Crimson Crystal", "Cyan Crystal", "Earth Crystal", "Light Crystal",
    -- Special
    "Lucky Block",
}

-- Monster sources (these drop from killing, not mining)
local MonsterSources = {
    "Bomber", "Skeleton Rogue", "Axe Skeleton", "Deathaxe Skeleton",
    "Elite Skeleton Rogue", "Elite Deathaxe Skeleton", "Blight Pyromancer", "Reaper",
    "Slime", "Blazing Slime",
}

--// ============================================================
--// SELL SELECTION STATE (Which ores to sell)
--// ============================================================

-- Default protected ores (OFF by default - require unlock)
local DefaultProtectedOres = {
    "Darkryte",
    "Arcane Crystal Ore",
    "Galaxite",
    "Fichillium",
    "Rainbow Crystal Ore",
    "Demonite",
}

-- Initialize sell selection (true = will sell, false = won't sell)
local SellSelection = {}
for _, ore in ipairs(OreDatabase) do
    local isDefaultProtected = table.find(DefaultProtectedOres, ore.Name) ~= nil
    SellSelection[ore.Name] = not isDefaultProtected
end

-- Function to check if ore should be sold
local function ShouldSellOre(oreName: string): boolean
    if SellSelection[oreName] == nil then
        -- Unknown ore, default to sell
        return true
    end
    return SellSelection[oreName] == true
end

-- Function to check if ore is default protected
local function IsDefaultProtected(oreName: string): boolean
    return table.find(DefaultProtectedOres, oreName) ~= nil
end

--// ============================================================
--// RARITY COLORS
--// ============================================================

local RarityColors = {
    Common = {Primary = Color3.fromRGB(180, 180, 180), Glow = Color3.fromRGB(200, 200, 200)},
    Uncommon = {Primary = Color3.fromRGB(50, 205, 50), Glow = Color3.fromRGB(100, 255, 100)},
    Rare = {Primary = Color3.fromRGB(30, 144, 255), Glow = Color3.fromRGB(100, 180, 255)},
    Epic = {Primary = Color3.fromRGB(163, 53, 238), Glow = Color3.fromRGB(200, 100, 255)},
    Legendary = {Primary = Color3.fromRGB(255, 165, 0), Glow = Color3.fromRGB(255, 200, 50)},
    Mythical = {Primary = Color3.fromRGB(255, 50, 100), Glow = Color3.fromRGB(255, 100, 150)},
    Divine = {Primary = Color3.fromRGB(255, 215, 0), Glow = Color3.fromRGB(255, 255, 200)},
    Relic = {Primary = Color3.fromRGB(0, 255, 255), Glow = Color3.fromRGB(100, 255, 255)},
}

--// ============================================================
--// THEME COLORS
--// ============================================================

local Theme = {
    Background = Color3.fromRGB(15, 15, 20),
    BackgroundSecondary = Color3.fromRGB(20, 20, 28),
    BackgroundTertiary = Color3.fromRGB(25, 25, 35),
    CardBackground = Color3.fromRGB(22, 22, 30),
    
    Accent = Color3.fromRGB(138, 43, 226),
    AccentLight = Color3.fromRGB(168, 85, 247),
    AccentDark = Color3.fromRGB(108, 33, 196),
    
    Success = Color3.fromRGB(34, 197, 94),
    Warning = Color3.fromRGB(234, 179, 8),
    Error = Color3.fromRGB(239, 68, 68),
    Info = Color3.fromRGB(59, 130, 246),
    
    TextPrimary = Color3.fromRGB(255, 255, 255),
    TextSecondary = Color3.fromRGB(156, 163, 175),
    TextMuted = Color3.fromRGB(107, 114, 128),
    
    Border = Color3.fromRGB(55, 55, 70),
    BorderLight = Color3.fromRGB(75, 75, 95),
    
    CategoryActive = Color3.fromRGB(138, 43, 226),
    CategoryInactive = Color3.fromRGB(40, 40, 55),
    
    PanelTransparency = 0.1,
    ButtonTransparency = 0.4,
}

--// ============================================================
--// STATE MANAGEMENT
--// ============================================================

local State = {
    isAutoMining = false,
    isAutoKilling = false,
    isAvoiding = false,
    isClosing = false,
    currentTarget = nil :: Instance?,
    currentCategory = "Auto",
    autoSellInProgress = false,
    isMainUIVisible = true,
}

--// ============================================================
--// CLEANUP TRACKING
--// ============================================================

local Connections: {Connection} = {}
local Instances: {Instance} = {}

local function TrackConnection(conn: Connection)
    table.insert(Connections, conn)
    return conn
end

local function TrackInstance(inst: Instance)
    table.insert(Instances, inst)
    return inst
end

--// ============================================================
--// SIGNAL CLASS
--// ============================================================

local Signal = {}
Signal.__index = Signal

function Signal.new<T...>(): Signal<T...>
    local self = setmetatable({}, Signal)
    self._listeners = {} :: {(T...) -> ()}
    self._waiting = {} :: {thread}
    return self
end

function Signal:Connect<T...>(callback: (T...) -> ()): Connection
    table.insert(self._listeners, callback)
    
    local connection = {
        Connected = true,
        Disconnect = function(conn)
            conn.Connected = false
            local idx = table.find(self._listeners, callback)
            if idx then
                table.remove(self._listeners, idx)
            end
        end
    }
    
    return connection :: any
end

function Signal:Fire<T...>(...: T...)
    for _, callback in ipairs(self._listeners) do
        task.spawn(callback, ...)
    end
    
    for _, thread in ipairs(self._waiting) do
        task.spawn(thread, ...)
    end
    table.clear(self._waiting)
end

function Signal:Wait<T...>(): T...
    local thread = coroutine.running()
    table.insert(self._waiting, thread)
    return coroutine.yield()
end

function Signal:Destroy()
    table.clear(self._listeners)
    table.clear(self._waiting)
end

--// ============================================================
--// SPRING PHYSICS CLASS
--// ============================================================

local SpringClass = {}
SpringClass.__index = SpringClass

function SpringClass.new(initial: Vector3 | number, damping: number?, speed: number?): Spring
    local isVector = typeof(initial) == "Vector3"
    
    return setmetatable({
        Position = initial,
        Velocity = isVector and Vector3.zero or 0,
        Target = initial,
        Damping = damping or 8,
        Speed = speed or 25,
    }, SpringClass)
end

function SpringClass:Update(dt: number): Vector3 | number
    local force = (self.Target - self.Position) * self.Speed
    self.Velocity = self.Velocity + force * dt
    self.Velocity = self.Velocity * math.max(0, 1 - self.Damping * dt)
    self.Position = self.Position + self.Velocity * dt
    return self.Position
end

function SpringClass:Impulse(force: Vector3 | number)
    self.Velocity = self.Velocity + force
end

function SpringClass:Reset(position: Vector3 | number)
    self.Position = position
    self.Target = position
    self.Velocity = typeof(position) == "Vector3" and Vector3.zero or 0
end

--// ============================================================
--// UTILITY FUNCTIONS
--// ============================================================

local function Tween(object: Instance, properties: {[string]: any}, duration: number?, style: Enum.EasingStyle?, direction: Enum.EasingDirection?)
    if not object or not object.Parent then return nil end
    
    local tweenInfo = TweenInfo.new(
        duration or 0.3,
        style or Enum.EasingStyle.Quint,
        direction or Enum.EasingDirection.Out
    )
    
    local tween = TweenService:Create(object, tweenInfo, properties)
    tween:Play()
    return tween
end

local function CreateInstance(className: string, properties: {[string]: any}): Instance
    local instance = Instance.new(className)
    
    for prop, value in pairs(properties) do
        if prop ~= "Parent" then
            pcall(function()
                instance[prop] = value
            end)
        end
    end
    
    if properties.Parent then
        instance.Parent = properties.Parent
    end
    
    return instance
end

local function AddCorner(parent: Instance, radius: number?): UICorner
    return CreateInstance("UICorner", {
        CornerRadius = UDim.new(0, radius or 8),
        Parent = parent
    }) :: UICorner
end

local function AddStroke(parent: Instance, color: Color3?, thickness: number?): UIStroke
    return CreateInstance("UIStroke", {
        Color = color or Theme.Border,
        Thickness = thickness or 1,
        Parent = parent
    }) :: UIStroke
end

local function AddPadding(parent: Instance, top: number, bottom: number?, left: number?, right: number?): UIPadding
    -- Support both single value and 4 separate values
    local paddingTop = top
    local paddingBottom = bottom or top
    local paddingLeft = left or top
    local paddingRight = right or top
    
    return CreateInstance("UIPadding", {
        PaddingTop = UDim.new(0, paddingTop),
        PaddingBottom = UDim.new(0, paddingBottom),
        PaddingLeft = UDim.new(0, paddingLeft),
        PaddingRight = UDim.new(0, paddingRight),
        Parent = parent
    }) :: UIPadding
end

--// ============================================================
--// ORE COOLDOWN SYSTEM
--// ============================================================

local OreCooldowns: {[Instance]: number} = {}
local ORE_COOLDOWN_DURATION = 15

local function IsOreOnCooldown(ore: Instance): boolean
    local expireTime = OreCooldowns[ore]
    if expireTime and tick() < expireTime then
        return true
    end
    if expireTime then
        OreCooldowns[ore] = nil
    end
    return false
end

local function SetOreCooldown(ore: Instance)
    OreCooldowns[ore] = tick() + ORE_COOLDOWN_DURATION
end

local function CleanupOreCooldowns()
    local currentTime = tick()
    for ore, expireTime in pairs(OreCooldowns) do
        if currentTime >= expireTime then
            OreCooldowns[ore] = nil
        end
    end
end

--// ============================================================
--// GOBLIN CAVE AVOIDANCE
--// ============================================================

local GOBLIN_CAVE_CENTER = Vector3.new(154.358368, 38.5363693, -111.641418)
local GOBLIN_CAVE_RADIUS_XZ = 80
local GOBLIN_CAVE_MIN_Y = 53.5

local function IsFromBlacklistedMap(ore: Instance): boolean
    if not ore or not ore.Parent then return false end
    
    local spawnLocation = ore.Parent
    if not spawnLocation then return false end
    
    local mapFolder = spawnLocation.Parent
    if not mapFolder then return false end
    
    local mapName = mapFolder.Name
    
    for _, blacklistedName in ipairs(Config.BlacklistedMaps) do
        if mapName == blacklistedName or mapName:find(blacklistedName) then
            return true
        end
    end
    
    return false
end

local function IsInGoblinCaveDangerZone(position: Vector3): boolean
    if not Config.AvoidGoblinCave then return false end
    
    local dx = position.X - GOBLIN_CAVE_CENTER.X
    local dz = position.Z - GOBLIN_CAVE_CENTER.Z
    local horizontalDist = math.sqrt(dx * dx + dz * dz)
    
    return horizontalDist < GOBLIN_CAVE_RADIUS_XZ and position.Y < GOBLIN_CAVE_MIN_Y
end

local function IsTooCloseToGoblinCave(position: Vector3): boolean
    if not Config.AvoidGoblinCave then return false end
    
    local dx = position.X - GOBLIN_CAVE_CENTER.X
    local dz = position.Z - GOBLIN_CAVE_CENTER.Z
    local horizontalDist = math.sqrt(dx * dx + dz * dz)
    
    return horizontalDist < GOBLIN_CAVE_RADIUS_XZ
end

--// ============================================================
--// STORED VALUES
--// ============================================================

local StoredHumanoidValues = {
    WalkSpeed = 16,
    JumpPower = 50,
    JumpHeight = 7.2,
}

local OriginalLighting: {[string]: any} = {}

--// ============================================================
--// MAIN GUI SETUP
--// ============================================================

local ScreenGui = CreateInstance("ScreenGui", {
    Name = "GladHub_TheForge_V7_Mobile",
    ResetOnSpawn = false,
    ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
    IgnoreGuiInset = true,
}) :: ScreenGui

pcall(function()
    ScreenGui.Parent = CoreGui
end)

if not ScreenGui.Parent then
    ScreenGui.Parent = playerGui
end

TrackInstance(ScreenGui)

--// ============================================================
--// TOAST NOTIFICATION SYSTEM
--// ============================================================

local ToastContainer = CreateInstance("Frame", {
    Name = "ToastContainer",
    Size = IsMobile and UDim2.new(0, 250, 1, 0) or UDim2.new(0, 300, 1, 0),
    Position = UDim2.new(1, IsMobile and -260 or -320, 0, 0),
    BackgroundTransparency = 1,
    Parent = ScreenGui
}) :: Frame

CreateInstance("UIListLayout", {
    SortOrder = Enum.SortOrder.LayoutOrder,
    Padding = UDim.new(0, 8),
    VerticalAlignment = Enum.VerticalAlignment.Bottom,
    Parent = ToastContainer
})

AddPadding(ToastContainer, 20)

local toastCount = 0

local function ShowToast(message: string, toastType: string?, duration: number?)
    if State.isClosing then return end
    
    toastCount += 1
    local currentCount = toastCount
    
    local colors = {
        success = Theme.Success,
        warning = Theme.Warning,
        error = Theme.Error,
        info = Theme.Info,
    }
    
    local symbols = {
        success = "+",
        warning = "!",
        error = "X",
        info = "i",
    }
    
    local color = colors[toastType or "info"] or Theme.Accent
    local symbol = symbols[toastType or "info"] or "-"
    
    local toast = CreateInstance("Frame", {
        Name = "Toast_" .. currentCount,
        Size = UDim2.new(1, 0, 0, IsMobile and 40 or 50),
        BackgroundColor3 = Theme.BackgroundSecondary,
        BackgroundTransparency = 0.1,
        LayoutOrder = -currentCount,
        Parent = ToastContainer
    }) :: Frame
    AddCorner(toast, 10)
    AddStroke(toast, color, 1)
    
    local iconBg = CreateInstance("Frame", {
        Size = IsMobile and UDim2.new(0, 28, 0, 28) or UDim2.new(0, 36, 0, 36),
        Position = UDim2.new(0, 6, 0.5, IsMobile and -14 or -18),
        BackgroundColor3 = color,
        Parent = toast
    }) :: Frame
    AddCorner(iconBg, 8)
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundTransparency = 1,
        Text = symbol,
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 12 or 16,
        Font = Enum.Font.GothamBold,
        Parent = iconBg
    })
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, -50, 1, 0),
        Position = UDim2.new(0, IsMobile and 40 or 50, 0, 0),
        BackgroundTransparency = 1,
        Text = message,
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 11 or 13,
        Font = Enum.Font.GothamMedium,
        TextXAlignment = Enum.TextXAlignment.Left,
        TextWrapped = true,
        Parent = toast
    })
    
    toast.Position = UDim2.new(1, 50, 0, 0)
    toast.BackgroundTransparency = 1
    iconBg.BackgroundTransparency = 1
    
    Tween(toast, {Position = UDim2.new(0, 0, 0, 0), BackgroundTransparency = 0.1}, 0.4, Enum.EasingStyle.Back)
    Tween(iconBg, {BackgroundTransparency = 0}, 0.3)
    
    task.delay(duration or 3, function()
        if toast and toast.Parent then
            Tween(toast, {Position = UDim2.new(1, 50, 0, 0), BackgroundTransparency = 1}, 0.3)
            task.delay(0.35, function()
                if toast and toast.Parent then
                    toast:Destroy()
                end
            end)
        end
    end)
end

--// ============================================================
--// LIVE TOAST SYSTEM (For Auto Sell - Persistent & Updates)
--// ============================================================

local LiveToast = {
    frame = nil :: Frame?,
    textLabel = nil :: TextLabel?,
    iconBg = nil :: Frame?,
    isVisible = false,
}

function LiveToast:Create()
    if self.frame then return end
    
    self.frame = CreateInstance("Frame", {
        Name = "LiveToast_AutoSell",
        Size = UDim2.new(1, 0, 0, IsMobile and 45 or 55),
        BackgroundColor3 = Theme.BackgroundSecondary,
        BackgroundTransparency = 0.1,
        LayoutOrder = -99999, -- Always on top
        Visible = false,
        Parent = ToastContainer
    }) :: Frame
    AddCorner(self.frame, 10)
    AddStroke(self.frame, Theme.Success, 2)
    
    self.iconBg = CreateInstance("Frame", {
        Size = IsMobile and UDim2.new(0, 32, 0, 32) or UDim2.new(0, 40, 0, 40),
        Position = UDim2.new(0, 6, 0.5, IsMobile and -16 or -20),
        BackgroundColor3 = Theme.Success,
        Parent = self.frame
    }) :: Frame
    AddCorner(self.iconBg, 8)
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundTransparency = 1,
        Text = "ðŸ’°",
        TextSize = IsMobile and 16 or 20,
        Font = Enum.Font.GothamBold,
        Parent = self.iconBg
    })
    
    self.textLabel = CreateInstance("TextLabel", {
        Name = "SoldText",
        Size = UDim2.new(1, -55, 1, 0),
        Position = UDim2.new(0, IsMobile and 45 or 55, 0, 0),
        BackgroundTransparency = 1,
        Text = "Sold: 0",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 13 or 16,
        Font = Enum.Font.GothamBold,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = self.frame
    }) :: TextLabel
end

function LiveToast:Show()
    if not self.frame then self:Create() end
    if self.isVisible then return end
    
    self.isVisible = true
    self.frame.Visible = true
    self.frame.Position = UDim2.new(1, 50, 0, 0)
    self.frame.BackgroundTransparency = 1
    
    Tween(self.frame, {Position = UDim2.new(0, 0, 0, 0), BackgroundTransparency = 0.1}, 0.4, Enum.EasingStyle.Back)
    if self.iconBg then
        self.iconBg.BackgroundTransparency = 1
        Tween(self.iconBg, {BackgroundTransparency = 0}, 0.3)
    end
end

function LiveToast:Hide()
    if not self.frame or not self.isVisible then return end
    
    self.isVisible = false
    Tween(self.frame, {Position = UDim2.new(1, 50, 0, 0), BackgroundTransparency = 1}, 0.3)
    task.delay(0.35, function()
        if self.frame then
            self.frame.Visible = false
        end
    end)
end

function LiveToast:Update(soldCount: number)
    if not self.frame then self:Create() end
    if not self.isVisible then self:Show() end
    
    if self.textLabel then
        self.textLabel.Text = string.format("Sold: %d items", soldCount)
    end
end

function LiveToast:Destroy()
    if self.frame then
        self.frame:Destroy()
        self.frame = nil
        self.textLabel = nil
        self.iconBg = nil
        self.isVisible = false
    end
end

--// ============================================================
--// SELL MANAGER UI (Ore Selection)
--// ============================================================

local SellManagerUI = {
    isOpen = false,
    mainFrame = nil :: Frame?,
    oreCards = {},
    dragConnection = nil,
    dragEndConnection = nil,
}

local IndexLists = {"Forgotten Kingdom List", "Goblin Cave List", "Iron Valley List"}

local function GetOreIndexPath()
    local success, result = pcall(function()
        return player.PlayerGui.Menu.Frame.Frame.Menus.Index.Pages.Ores
    end)
    return success and result or nil
end

local function CloneOreIcon(oreName)
    local oresFolder = GetOreIndexPath()
    if not oresFolder then return nil end
    
    for _, listName in ipairs(IndexLists) do
        local list = oresFolder:FindFirstChild(listName)
        if list then
            local oreEntry = list:FindFirstChild(oreName)
            if oreEntry then
                local main = oreEntry:FindFirstChild("Main")
                if main then
                    local viewport = main:FindFirstChild("ViewportFrame")
                    if viewport then return viewport:Clone() end
                end
            end
        end
    end
    return nil
end

function SellManagerUI:Open()
    if self.isOpen then return end
    self.isOpen = true
    
    local targetSize = IsMobile and UDim2.new(0, 360, 0, 480) or UDim2.new(0, 480, 0, 580)
    
    -- Create dark overlay (blocks clicks to elements behind)
    local overlay = CreateInstance("Frame", {
        Name = "SellManagerOverlay",
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundColor3 = Color3.fromRGB(0, 0, 0),
        BackgroundTransparency = 1, -- Start invisible
        ZIndex = 100,
        Active = true, -- Absorb clicks
        Parent = ScreenGui
    })
    
    -- Main frame (Glassy) - FIXED: Start at center with target size, Active to absorb clicks
    self.mainFrame = CreateInstance("Frame", {
        Name = "SellManagerFrame",
        Size = targetSize, -- Start at full size
        Position = UDim2.new(0.5, 0, 0.5, 0),
        AnchorPoint = Vector2.new(0.5, 0.5),
        BackgroundColor3 = Theme.Background,
        BackgroundTransparency = 0.7,
        ZIndex = 101,
        Active = true, -- CRITICAL: Absorb clicks so they don't pass to overlay
        Parent = ScreenGui
    })
    AddCorner(self.mainFrame, 16)
    AddStroke(self.mainFrame, Theme.Accent, 2)
    
    -- Animate: Scale from small to full size
    self.mainFrame.Size = UDim2.new(0, 0, 0, 0)
    Tween(self.mainFrame, {Size = targetSize}, 0.4, Enum.EasingStyle.Back)
    Tween(overlay, {BackgroundTransparency = 0.5}, 0.3)
    
    -- Header (also needs Active = true)
    local header = CreateInstance("Frame", {
        Size = UDim2.new(1, 0, 0, IsMobile and 55 or 65),
        BackgroundColor3 = Theme.BackgroundSecondary,
        BackgroundTransparency = 0.6,
        ZIndex = 102,
        Active = true,
        Parent = self.mainFrame
    })
    AddCorner(header, 16)
    
    -- Title Icon (replaces emoji)
    CreateInstance("ImageLabel", {
        Size = UDim2.new(0, IsMobile and 22 or 26, 0, IsMobile and 22 or 26),
        Position = UDim2.new(0, 12, 0, IsMobile and 8 or 12),
        BackgroundTransparency = 1,
        Image = "rbxassetid://123680618370738",
        ZIndex = 103,
        Parent = header
    })
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, -80, 0, 24),
        Position = UDim2.new(0, IsMobile and 38 or 44, 0, IsMobile and 8 or 12),
        BackgroundTransparency = 1,
        Text = "SELL MANAGER",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 18 or 22,
        Font = Enum.Font.GothamBlack,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 103,
        Parent = header
    })
    
    -- Lock Icon for subtitle
    local subtitleFrame = CreateInstance("Frame", {
        Size = UDim2.new(1, -60, 0, 16),
        Position = UDim2.new(0, IsMobile and 38 or 44, 0, IsMobile and 32 or 38),
        BackgroundTransparency = 1,
        ZIndex = 103,
        Parent = header
    })
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(0, 120, 1, 0),
        BackgroundTransparency = 1,
        Text = "Toggle ores to sell",
        TextColor3 = Theme.TextSecondary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.Gotham,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 103,
        Parent = subtitleFrame
    })
    
    CreateInstance("ImageLabel", {
        Size = UDim2.new(0, 12, 0, 12),
        Position = UDim2.new(0, 125, 0.5, -6),
        BackgroundTransparency = 1,
        Image = "rbxassetid://15117261710",
        ZIndex = 103,
        Parent = subtitleFrame
    })
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(0, 80, 1, 0),
        Position = UDim2.new(0, 140, 0, 0),
        BackgroundTransparency = 1,
        Text = "= Protected",
        TextColor3 = Theme.TextSecondary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.Gotham,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 103,
        Parent = subtitleFrame
    })
    
    -- Close button
    local closeBtn = CreateInstance("TextButton", {
        Size = UDim2.new(0, IsMobile and 36 or 42, 0, IsMobile and 36 or 42),
        Position = UDim2.new(1, IsMobile and -44 or -52, 0.5, IsMobile and -18 or -21),
        BackgroundColor3 = Theme.Error,
        BackgroundTransparency = 0.4,
        Text = "âœ•",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 16 or 18,
        Font = Enum.Font.GothamBold,
        ZIndex = 103,
        Parent = header
    })
    AddCorner(closeBtn, 10)
    
    closeBtn.MouseButton1Click:Connect(function()
        self:Close()
    end)
    
    -- Stats bar
    local statsBar = CreateInstance("Frame", {
        Size = UDim2.new(1, -20, 0, IsMobile and 40 or 48),
        Position = UDim2.new(0, 10, 0, IsMobile and 60 or 72),
        BackgroundColor3 = Theme.BackgroundTertiary,
        BackgroundTransparency = 0.5,
        ZIndex = 102,
        Active = true,
        Parent = self.mainFrame
    })
    AddCorner(statsBar, 10)
    
    local selectedLabel = CreateInstance("TextLabel", {
        Name = "SelectedLabel",
        Size = UDim2.new(0.5, 0, 1, 0),
        Position = UDim2.new(0, 10, 0, 0),
        BackgroundTransparency = 1,
        Text = "Selected: 0/0",
        TextColor3 = Theme.Success,
        TextSize = IsMobile and 12 or 14,
        Font = Enum.Font.GothamBold,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 103,
        Parent = statsBar
    })
    
    -- Select All button
    local selectAllBtn = CreateInstance("TextButton", {
        Size = UDim2.new(0, IsMobile and 50 or 65, 0, IsMobile and 26 or 32),
        Position = UDim2.new(1, IsMobile and -110 or -145, 0.5, IsMobile and -13 or -16),
        BackgroundColor3 = Theme.Success,
        BackgroundTransparency = 0.4,
        Text = "All",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.GothamBold,
        ZIndex = 103,
        Parent = statsBar
    })
    AddCorner(selectAllBtn, 6)
    
    -- Deselect All button
    local deselectAllBtn = CreateInstance("TextButton", {
        Size = UDim2.new(0, IsMobile and 50 or 65, 0, IsMobile and 26 or 32),
        Position = UDim2.new(1, IsMobile and -55 or -72, 0.5, IsMobile and -13 or -16),
        BackgroundColor3 = Theme.Error,
        BackgroundTransparency = 0.4,
        Text = "None",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.GothamBold,
        ZIndex = 103,
        Parent = statsBar
    })
    AddCorner(deselectAllBtn, 6)
    
    -- Ore list container
    local listContainer = CreateInstance("Frame", {
        Size = UDim2.new(1, -20, 1, IsMobile and -150 or -175),
        Position = UDim2.new(0, 10, 0, IsMobile and 105 or 127),
        BackgroundColor3 = Theme.BackgroundSecondary,
        BackgroundTransparency = 0.6,
        ClipsDescendants = true,
        ZIndex = 102,
        Active = true,
        Parent = self.mainFrame
    })
    AddCorner(listContainer, 12)
    
    local oreList = CreateInstance("ScrollingFrame", {
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundTransparency = 1,
        ScrollBarThickness = 4,
        ScrollBarImageColor3 = Theme.Accent,
        CanvasSize = UDim2.new(0, 0, 0, 0),
        AutomaticCanvasSize = Enum.AutomaticSize.Y,
        ZIndex = 103,
        Active = true,
        Parent = listContainer
    })
    
    CreateInstance("UIListLayout", {
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 5),
        Parent = oreList
    })
    AddPadding(oreList, 6, 6, 6, 6)
    
    -- Warning label
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, -20, 0, 20),
        Position = UDim2.new(0, 10, 1, IsMobile and -38 or -42),
        BackgroundTransparency = 1,
        Text = "âš ï¸ Protected ores require confirmation to enable",
        TextColor3 = Theme.Warning,
        TextSize = IsMobile and 9 or 11,
        Font = Enum.Font.Gotham,
        ZIndex = 103,
        Parent = self.mainFrame
    })
    
    -- Update selected count function
    local function UpdateCount()
        local selected = 0
        for _, ore in ipairs(OreDatabase) do
            if SellSelection[ore.Name] then selected += 1 end
        end
        selectedLabel.Text = string.format("Selected: %d / %d", selected, #OreDatabase)
    end
    
    -- Create ore cards
    table.clear(self.oreCards)
    
    for i, ore in pairs(OreDatabase) do
        local rarityColor = RarityColors[ore.Rarity] or RarityColors.Common
        local isEnabled = SellSelection[ore.Name]
        local isProtected = IsDefaultProtected(ore.Name)
        
        local card = CreateInstance("Frame", {
            Name = ore.Name,
            Size = UDim2.new(1, 0, 0, IsMobile and 52 or 62),
            BackgroundColor3 = Theme.CardBackground,
            BackgroundTransparency = 0.5,
            LayoutOrder = i,
            ZIndex = 104,
            Active = true,
            Parent = oreList
        })
        AddCorner(card, 8)
        AddStroke(card, isProtected and Theme.Warning or Theme.Border, 1)
        
        -- Accent bar
        CreateInstance("Frame", {
            Size = UDim2.new(0, 3, 1, -8),
            Position = UDim2.new(0, 4, 0, 4),
            BackgroundColor3 = rarityColor.Primary,
            ZIndex = 105,
            Parent = card
        })
        
        -- Icon container
        local iconBg = CreateInstance("Frame", {
            Size = UDim2.new(0, IsMobile and 36 or 44, 0, IsMobile and 36 or 44),
            Position = UDim2.new(0, 12, 0.5, IsMobile and -18 or -22),
            BackgroundColor3 = rarityColor.Primary,
            BackgroundTransparency = 0.7,
            ClipsDescendants = true,
            ZIndex = 105,
            Parent = card
        })
        AddCorner(iconBg, 8)
        
        -- Try to get real icon
        local realIcon = CloneOreIcon(ore.Name)
        if realIcon then
            realIcon.Size = UDim2.new(1, 0, 1, 0)
            realIcon.Position = UDim2.new(0.5, 0, 0.5, 0)
            realIcon.AnchorPoint = Vector2.new(0.5, 0.5)
            realIcon.BackgroundTransparency = 1
            realIcon.ZIndex = 106
            realIcon.Parent = iconBg
        else
            CreateInstance("TextLabel", {
                Size = UDim2.new(1, 0, 1, 0),
                BackgroundTransparency = 1,
                Text = string.sub(ore.Name, 1, 2):upper(),
                TextColor3 = Theme.TextPrimary,
                TextSize = IsMobile and 12 or 16,
                Font = Enum.Font.GothamBlack,
                ZIndex = 106,
                Parent = iconBg
            })
        end
        
        -- Protected icon (Lock image instead of emoji)
        if isProtected then
            CreateInstance("ImageLabel", {
                Size = UDim2.new(0, 14, 0, 14),
                Position = UDim2.new(0, IsMobile and 52 or 62, 0, IsMobile and 4 or 6),
                BackgroundTransparency = 1,
                Image = "rbxassetid://15117261710",
                ImageColor3 = Theme.Warning,
                ZIndex = 106,
                Parent = card
            })
        end
        
        -- Ore name
        CreateInstance("TextLabel", {
            Size = UDim2.new(1, IsMobile and -110 or -130, 0, 20),
            Position = UDim2.new(0, IsMobile and 54 or 66, 0, IsMobile and 6 or 8),
            BackgroundTransparency = 1,
            Text = ore.Name,
            TextColor3 = rarityColor.Primary,
            TextSize = IsMobile and 12 or 14,
            Font = Enum.Font.GothamBold,
            TextXAlignment = Enum.TextXAlignment.Left,
            TextTruncate = Enum.TextTruncate.AtEnd,
            ZIndex = 105,
            Parent = card
        })
        
        -- Rarity + Chance
        CreateInstance("TextLabel", {
            Size = UDim2.new(1, IsMobile and -110 or -130, 0, 16),
            Position = UDim2.new(0, IsMobile and 54 or 66, 0, IsMobile and 26 or 30),
            BackgroundTransparency = 1,
            Text = string.format("%s â€¢ %s â€¢ $%.2f", ore.Rarity:upper(), ore.Chance, ore.Price),
            TextColor3 = Theme.TextSecondary,
            TextSize = IsMobile and 9 or 11,
            Font = Enum.Font.Gotham,
            TextXAlignment = Enum.TextXAlignment.Left,
            ZIndex = 105,
            Parent = card
        })
        
        -- Toggle
        local toggleBg = CreateInstance("Frame", {
            Name = "ToggleBg",
            Size = UDim2.new(0, IsMobile and 44 or 54, 0, IsMobile and 24 or 28),
            Position = UDim2.new(1, IsMobile and -52 or -64, 0.5, IsMobile and -12 or -14),
            BackgroundColor3 = isEnabled and Theme.Success or Theme.BackgroundTertiary,
            BackgroundTransparency = 0.4,
            ZIndex = 105,
            Parent = card
        })
        AddCorner(toggleBg, 14)
        AddStroke(toggleBg, isEnabled and Theme.Success or Theme.Border, 1)
        
        local toggleCircle = CreateInstance("Frame", {
            Name = "Circle",
            Size = UDim2.new(0, IsMobile and 18 or 22, 0, IsMobile and 18 or 22),
            Position = isEnabled 
                and UDim2.new(1, IsMobile and -21 or -25, 0.5, IsMobile and -9 or -11)
                or UDim2.new(0, 3, 0.5, IsMobile and -9 or -11),
            BackgroundColor3 = Theme.TextPrimary,
            ZIndex = 106,
            Parent = toggleBg
        })
        AddCorner(toggleCircle, 11)
        
        self.oreCards[ore.Name] = {Card = card, ToggleBg = toggleBg, Circle = toggleCircle}
        
        -- Click handler
        local debounce = false
        card.InputBegan:Connect(function(input)
            if debounce then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                debounce = true
                
                local currentState = SellSelection[ore.Name]
                local newState = not currentState
                
                -- If enabling a protected ore, show warning
                if isProtected and newState == true then
                    -- Show confirmation toast
                    ShowToast(string.format("âš ï¸ Enabling %s for sale!", ore.Name), "warning", 3)
                end
                
                SellSelection[ore.Name] = newState
                
                -- Animate toggle
                Tween(toggleBg, {BackgroundColor3 = newState and Theme.Success or Theme.BackgroundTertiary}, 0.2)
                Tween(toggleCircle, {
                    Position = newState 
                        and UDim2.new(1, IsMobile and -21 or -25, 0.5, IsMobile and -9 or -11)
                        or UDim2.new(0, 3, 0.5, IsMobile and -9 or -11)
                }, 0.2, Enum.EasingStyle.Back)
                
                local stroke = toggleBg:FindFirstChildOfClass("UIStroke")
                if stroke then
                    Tween(stroke, {Color = newState and Theme.Success or Theme.Border}, 0.2)
                end
                
                UpdateCount()
                task.delay(0.15, function() debounce = false end)
            end
        end)
    end
    
    -- Select All handler
    selectAllBtn.MouseButton1Click:Connect(function()
        for _, ore in ipairs(OreDatabase) do
            if not IsDefaultProtected(ore.Name) then
                SellSelection[ore.Name] = true
            end
        end
        
        for name, cardData in pairs(self.oreCards) do
            if SellSelection[name] then
                Tween(cardData.ToggleBg, {BackgroundColor3 = Theme.Success}, 0.2)
                Tween(cardData.Circle, {
                    Position = UDim2.new(1, IsMobile and -21 or -25, 0.5, IsMobile and -9 or -11)
                }, 0.2, Enum.EasingStyle.Back)
                local stroke = cardData.ToggleBg:FindFirstChildOfClass("UIStroke")
                if stroke then Tween(stroke, {Color = Theme.Success}, 0.2) end
            end
        end
        UpdateCount()
        ShowToast("All non-protected ores enabled", "success")
    end)
    
    -- Deselect All handler
    deselectAllBtn.MouseButton1Click:Connect(function()
        for _, ore in ipairs(OreDatabase) do
            SellSelection[ore.Name] = false
        end
        
        for name, cardData in pairs(self.oreCards) do
            Tween(cardData.ToggleBg, {BackgroundColor3 = Theme.BackgroundTertiary}, 0.2)
            Tween(cardData.Circle, {
                Position = UDim2.new(0, 3, 0.5, IsMobile and -9 or -11)
            }, 0.2, Enum.EasingStyle.Back)
            local stroke = cardData.ToggleBg:FindFirstChildOfClass("UIStroke")
            if stroke then Tween(stroke, {Color = Theme.Border}, 0.2) end
        end
        UpdateCount()
        ShowToast("All ores disabled - Nothing will be sold!", "warning")
    end)
    
    -- NOTE: Removed overlay click-to-close due to input issues
    -- Use X button to close instead
    
    -- Make draggable (with proper state management)
    local isDragging = false
    local dragStartPos = nil
    local frameStartPos = nil
    local dragConnection = nil
    local dragEndConnection = nil
    
    header.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
            dragStartPos = input.Position
            frameStartPos = self.mainFrame.Position
            
            -- Create drag connection only when starting to drag
            if dragConnection then dragConnection:Disconnect() end
            dragConnection = UserInputService.InputChanged:Connect(function(moveInput)
                if isDragging and self.mainFrame and dragStartPos and frameStartPos then
                    if moveInput.UserInputType == Enum.UserInputType.MouseMovement or moveInput.UserInputType == Enum.UserInputType.Touch then
                        local delta = moveInput.Position - dragStartPos
                        self.mainFrame.Position = UDim2.new(
                            frameStartPos.X.Scale, frameStartPos.X.Offset + delta.X,
                            frameStartPos.Y.Scale, frameStartPos.Y.Offset + delta.Y
                        )
                    end
                end
            end)
        end
    end)
    
    header.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = false
            dragStartPos = nil
            frameStartPos = nil
            if dragConnection then
                dragConnection:Disconnect()
                dragConnection = nil
            end
        end
    end)
    
    -- Also stop dragging on global input end
    dragEndConnection = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = false
            dragStartPos = nil
            frameStartPos = nil
            if dragConnection then
                dragConnection:Disconnect()
                dragConnection = nil
            end
        end
    end)
    
    -- Store connections for cleanup
    self.dragConnection = dragConnection
    self.dragEndConnection = dragEndConnection
    
    UpdateCount()
end

function SellManagerUI:Close()
    if not self.isOpen then return end
    self.isOpen = false
    
    -- Cleanup drag connections
    if self.dragConnection then
        self.dragConnection:Disconnect()
        self.dragConnection = nil
    end
    if self.dragEndConnection then
        self.dragEndConnection:Disconnect()
        self.dragEndConnection = nil
    end
    
    local overlay = ScreenGui:FindFirstChild("SellManagerOverlay")
    if overlay then
        Tween(overlay, {BackgroundTransparency = 1}, 0.2)
        task.delay(0.25, function()
            if overlay then overlay:Destroy() end
        end)
    end
    
    if self.mainFrame then
        Tween(self.mainFrame, {Size = UDim2.new(0, 0, 0, 0)}, 0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In)
        task.delay(0.25, function()
            if self.mainFrame then
                self.mainFrame:Destroy()
                self.mainFrame = nil
            end
        end)
    end
    
    table.clear(self.oreCards)
    
    -- Show summary
    local enabled = 0
    for _, v in pairs(SellSelection) do
        if v then enabled += 1 end
    end
    ShowToast(string.format("Sell Manager: %d/%d ores enabled", enabled, #OreDatabase), "info")
end

--// ============================================================
--// ORE MANAGER UI (Smart Source-Based Farming)
--// ============================================================

-- Ore Farm Selection (which ORES user wants)
local OreFarmSelection = {}

-- Initialize: common/uncommon ores OFF, rare+ ON by default
for _, ore in ipairs(OreDatabase) do
    local isLowTier = ore.Rarity == "Common" or ore.Rarity == "Uncommon"
    OreFarmSelection[ore.Name] = not isLowTier
end

-- Function to calculate required SOURCE ROCKS from selected ores
local function CalculateRequiredSources(): {string}
    local sourcesNeeded = {}
    local sourceSet = {}
    
    for oreName, enabled in pairs(OreFarmSelection) do
        if enabled then
            -- Find ore in database
            for _, ore in ipairs(OreDatabase) do
                if ore.Name == oreName and ore.Sources then
                    for _, source in ipairs(ore.Sources) do
                        -- Skip monster sources and special sources
                        if source ~= "All" and not table.find(MonsterSources, source) then
                            if not sourceSet[source] then
                                sourceSet[source] = true
                                table.insert(sourcesNeeded, source)
                            end
                        end
                    end
                    break
                end
            end
        end
    end
    
    table.sort(sourcesNeeded)
    return sourcesNeeded
end

-- Function to get ores that drop from a source
local function GetOresFromSource(sourceName: string): {string}
    local ores = {}
    for _, ore in ipairs(OreDatabase) do
        if ore.Sources and table.find(ore.Sources, sourceName) then
            if OreFarmSelection[ore.Name] then
                table.insert(ores, ore.Name)
            end
        end
    end
    return ores
end

local OreManagerUI = {
    isOpen = false,
    mainFrame = nil :: Frame?,
    oreCards = {},
    dragConnection = nil,
    dragEndConnection = nil,
    sourcesLabel = nil,
}

function OreManagerUI:Open()
    if self.isOpen then return end
    self.isOpen = true
    
    local targetSize = IsMobile and UDim2.new(0, 360, 0, 520) or UDim2.new(0, 500, 0, 620)
    
    local overlay = CreateInstance("Frame", {
        Name = "OreManagerOverlay",
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundColor3 = Color3.fromRGB(0, 0, 0),
        BackgroundTransparency = 1,
        ZIndex = 100,
        Active = true,
        Parent = ScreenGui
    })
    
    self.mainFrame = CreateInstance("Frame", {
        Name = "OreManagerFrame",
        Size = targetSize,
        Position = UDim2.new(0.5, 0, 0.5, 0),
        AnchorPoint = Vector2.new(0.5, 0.5),
        BackgroundColor3 = Theme.Background,
        BackgroundTransparency = 0.7,
        ZIndex = 101,
        Active = true,
        Parent = ScreenGui
    })
    AddCorner(self.mainFrame, 16)
    AddStroke(self.mainFrame, Color3.fromRGB(100, 200, 100), 2)
    
    self.mainFrame.Size = UDim2.new(0, 0, 0, 0)
    Tween(self.mainFrame, {Size = targetSize}, 0.4, Enum.EasingStyle.Back)
    Tween(overlay, {BackgroundTransparency = 0.5}, 0.3)
    
    -- Header
    local header = CreateInstance("Frame", {
        Size = UDim2.new(1, 0, 0, IsMobile and 55 or 65),
        BackgroundColor3 = Theme.BackgroundSecondary,
        BackgroundTransparency = 0.6,
        ZIndex = 102,
        Active = true,
        Parent = self.mainFrame
    })
    AddCorner(header, 16)
    
    CreateInstance("ImageLabel", {
        Size = UDim2.new(0, IsMobile and 22 or 26, 0, IsMobile and 22 or 26),
        Position = UDim2.new(0, 12, 0, IsMobile and 8 or 12),
        BackgroundTransparency = 1,
        Image = "rbxassetid://123680618370738",
        ImageColor3 = Color3.fromRGB(100, 200, 100),
        ZIndex = 103,
        Parent = header
    })
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, -80, 0, 24),
        Position = UDim2.new(0, IsMobile and 38 or 44, 0, IsMobile and 8 or 12),
        BackgroundTransparency = 1,
        Text = "ORE MANAGER",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 18 or 22,
        Font = Enum.Font.GothamBlack,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 103,
        Parent = header
    })
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, -60, 0, 16),
        Position = UDim2.new(0, IsMobile and 38 or 44, 0, IsMobile and 32 or 38),
        BackgroundTransparency = 1,
        Text = "Select ores > Auto-mines source rocks",
        TextColor3 = Theme.TextSecondary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.Gotham,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 103,
        Parent = header
    })
    
    local closeBtn = CreateInstance("TextButton", {
        Size = UDim2.new(0, IsMobile and 36 or 42, 0, IsMobile and 36 or 42),
        Position = UDim2.new(1, IsMobile and -44 or -52, 0.5, IsMobile and -18 or -21),
        BackgroundColor3 = Theme.Error,
        BackgroundTransparency = 0.4,
        Text = "X",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 16 or 18,
        Font = Enum.Font.GothamBold,
        ZIndex = 103,
        Parent = header
    })
    AddCorner(closeBtn, 10)
    
    closeBtn.MouseButton1Click:Connect(function()
        self:Close()
    end)
    
    -- Sources status bar (shows which rocks will be mined)
    local sourcesBar = CreateInstance("Frame", {
        Size = UDim2.new(1, -20, 0, IsMobile and 50 or 60),
        Position = UDim2.new(0, 10, 0, IsMobile and 60 or 72),
        BackgroundColor3 = Color3.fromRGB(30, 50, 30),
        BackgroundTransparency = 0.5,
        ZIndex = 102,
        Active = true,
        Parent = self.mainFrame
    })
    AddCorner(sourcesBar, 10)
    AddStroke(sourcesBar, Color3.fromRGB(100, 200, 100), 1)
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, -10, 0, 16),
        Position = UDim2.new(0, 8, 0, 4),
        BackgroundTransparency = 1,
        Text = "WILL MINE:",
        TextColor3 = Color3.fromRGB(100, 200, 100),
        TextSize = IsMobile and 10 or 11,
        Font = Enum.Font.GothamBold,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 103,
        Parent = sourcesBar
    })
    
    self.sourcesLabel = CreateInstance("TextLabel", {
        Name = "SourcesList",
        Size = UDim2.new(1, -16, 0, IsMobile and 28 or 36),
        Position = UDim2.new(0, 8, 0, IsMobile and 20 or 22),
        BackgroundTransparency = 1,
        Text = "None selected",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 9 or 11,
        Font = Enum.Font.Gotham,
        TextXAlignment = Enum.TextXAlignment.Left,
        TextWrapped = true,
        ZIndex = 103,
        Parent = sourcesBar
    })
    
    -- Stats bar with buttons
    local statsBar = CreateInstance("Frame", {
        Size = UDim2.new(1, -20, 0, IsMobile and 36 or 42),
        Position = UDim2.new(0, 10, 0, IsMobile and 115 or 138),
        BackgroundColor3 = Theme.BackgroundTertiary,
        BackgroundTransparency = 0.5,
        ZIndex = 102,
        Active = true,
        Parent = self.mainFrame
    })
    AddCorner(statsBar, 10)
    
    local selectedLabel = CreateInstance("TextLabel", {
        Name = "SelectedLabel",
        Size = UDim2.new(0.35, 0, 1, 0),
        Position = UDim2.new(0, 10, 0, 0),
        BackgroundTransparency = 1,
        Text = "Ores: 0",
        TextColor3 = Color3.fromRGB(100, 200, 100),
        TextSize = IsMobile and 11 or 13,
        Font = Enum.Font.GothamBold,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 103,
        Parent = statsBar
    })
    
    -- Apply button (main action)
    local applyBtn = CreateInstance("TextButton", {
        Size = UDim2.new(0, IsMobile and 60 or 75, 0, IsMobile and 24 or 28),
        Position = UDim2.new(1, IsMobile and -175 or -220, 0.5, IsMobile and -12 or -14),
        BackgroundColor3 = Color3.fromRGB(50, 150, 50),
        BackgroundTransparency = 0.3,
        Text = "APPLY",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.GothamBold,
        ZIndex = 103,
        Parent = statsBar
    })
    AddCorner(applyBtn, 6)
    
    local selectAllBtn = CreateInstance("TextButton", {
        Size = UDim2.new(0, IsMobile and 40 or 50, 0, IsMobile and 24 or 28),
        Position = UDim2.new(1, IsMobile and -110 or -138, 0.5, IsMobile and -12 or -14),
        BackgroundColor3 = Theme.Success,
        BackgroundTransparency = 0.4,
        Text = "All",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.GothamBold,
        ZIndex = 103,
        Parent = statsBar
    })
    AddCorner(selectAllBtn, 6)
    
    local deselectAllBtn = CreateInstance("TextButton", {
        Size = UDim2.new(0, IsMobile and 50 or 65, 0, IsMobile and 24 or 28),
        Position = UDim2.new(1, IsMobile and -55 or -72, 0.5, IsMobile and -12 or -14),
        BackgroundColor3 = Theme.Error,
        BackgroundTransparency = 0.4,
        Text = "None",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.GothamBold,
        ZIndex = 103,
        Parent = statsBar
    })
    AddCorner(deselectAllBtn, 6)
    
    -- Ore list
    local listContainer = CreateInstance("Frame", {
        Size = UDim2.new(1, -20, 1, IsMobile and -200 or -235),
        Position = UDim2.new(0, 10, 0, IsMobile and 156 or 186),
        BackgroundColor3 = Theme.BackgroundSecondary,
        BackgroundTransparency = 0.6,
        ClipsDescendants = true,
        ZIndex = 102,
        Active = true,
        Parent = self.mainFrame
    })
    AddCorner(listContainer, 12)
    
    local oreList = CreateInstance("ScrollingFrame", {
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundTransparency = 1,
        ScrollBarThickness = 4,
        ScrollBarImageColor3 = Color3.fromRGB(100, 200, 100),
        CanvasSize = UDim2.new(0, 0, 0, 0),
        AutomaticCanvasSize = Enum.AutomaticSize.Y,
        ZIndex = 103,
        Active = true,
        Parent = listContainer
    })
    
    CreateInstance("UIListLayout", {
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 4),
        Parent = oreList
    })
    AddPadding(oreList, 6, 6, 6, 6)
    
    local function UpdateSourcesDisplay()
        local sources = CalculateRequiredSources()
        if #sources == 0 then
            self.sourcesLabel.Text = "None selected"
            self.sourcesLabel.TextColor3 = Theme.TextSecondary
        else
            self.sourcesLabel.Text = table.concat(sources, ", ")
            self.sourcesLabel.TextColor3 = Theme.TextPrimary
        end
    end
    
    local function UpdateCount()
        local selected = 0
        for _, v in pairs(OreFarmSelection) do
            if v then selected += 1 end
        end
        selectedLabel.Text = string.format("Ores: %d", selected)
        UpdateSourcesDisplay()
    end
    
    -- Create ore cards (skip essences and unobtainable)
    local cardOrder = 0
    for i, ore in pairs(OreDatabase) do
        -- Skip essences and unobtainable
        if ore.Name:find("Essence") or ore.Rarity == "Divine" or ore.Rarity == "Relic" then
            continue
        end
        
        -- Skip monster-only drops
        local isMonsterDrop = true
        if ore.Sources then
            for _, source in ipairs(ore.Sources) do
                if not table.find(MonsterSources, source) and source ~= "All" then
                    isMonsterDrop = false
                    break
                end
            end
        end
        if isMonsterDrop and ore.Sources and #ore.Sources > 0 then continue end
        
        cardOrder += 1
        local rarityColor = RarityColors[ore.Rarity] or RarityColors.Common
        local isEnabled = OreFarmSelection[ore.Name] == true
        
        local card = CreateInstance("Frame", {
            Name = ore.Name,
            Size = UDim2.new(1, 0, 0, IsMobile and 58 or 68),
            BackgroundColor3 = Theme.CardBackground,
            BackgroundTransparency = 0.5,
            LayoutOrder = cardOrder,
            ZIndex = 104,
            Active = true,
            Parent = oreList
        })
        AddCorner(card, 8)
        AddStroke(card, Theme.Border, 1)
        
        -- Accent bar
        CreateInstance("Frame", {
            Size = UDim2.new(0, 3, 1, -8),
            Position = UDim2.new(0, 4, 0, 4),
            BackgroundColor3 = rarityColor.Primary,
            ZIndex = 105,
            Parent = card
        })
        
        -- Icon
        local iconBg = CreateInstance("Frame", {
            Size = UDim2.new(0, IsMobile and 36 or 44, 0, IsMobile and 36 or 44),
            Position = UDim2.new(0, 12, 0.5, IsMobile and -18 or -22),
            BackgroundColor3 = rarityColor.Primary,
            BackgroundTransparency = 0.7,
            ClipsDescendants = true,
            ZIndex = 105,
            Parent = card
        })
        AddCorner(iconBg, 8)
        
        local realIcon = CloneOreIcon(ore.Name)
        if realIcon then
            realIcon.Size = UDim2.new(1.2, 0, 1.2, 0)
            realIcon.Position = UDim2.new(0.5, 0, 0.5, 0)
            realIcon.AnchorPoint = Vector2.new(0.5, 0.5)
            realIcon.ZIndex = 106
            realIcon.Parent = iconBg
        else
            CreateInstance("TextLabel", {
                Size = UDim2.new(1, 0, 1, 0),
                BackgroundTransparency = 1,
                Text = ore.Name:sub(1, 2):upper(),
                TextColor3 = rarityColor.Primary,
                TextSize = IsMobile and 14 or 18,
                Font = Enum.Font.GothamBlack,
                ZIndex = 106,
                Parent = iconBg
            })
        end
        
        -- Ore name
        CreateInstance("TextLabel", {
            Size = UDim2.new(1, IsMobile and -110 or -130, 0, 18),
            Position = UDim2.new(0, IsMobile and 54 or 66, 0, IsMobile and 4 or 6),
            BackgroundTransparency = 1,
            Text = ore.Name,
            TextColor3 = rarityColor.Primary,
            TextSize = IsMobile and 12 or 14,
            Font = Enum.Font.GothamBold,
            TextXAlignment = Enum.TextXAlignment.Left,
            TextTruncate = Enum.TextTruncate.AtEnd,
            ZIndex = 105,
            Parent = card
        })
        
        -- Rarity + Chance
        CreateInstance("TextLabel", {
            Size = UDim2.new(1, IsMobile and -110 or -130, 0, 14),
            Position = UDim2.new(0, IsMobile and 54 or 66, 0, IsMobile and 22 or 24),
            BackgroundTransparency = 1,
            Text = string.format("%s | %s", ore.Rarity:upper(), ore.Chance),
            TextColor3 = Theme.TextSecondary,
            TextSize = IsMobile and 9 or 10,
            Font = Enum.Font.Gotham,
            TextXAlignment = Enum.TextXAlignment.Left,
            ZIndex = 105,
            Parent = card
        })
        
        -- Sources (what rocks to mine)
        local sourcesText = ore.Sources and #ore.Sources > 0 and table.concat(ore.Sources, ", ") or "N/A"
        CreateInstance("TextLabel", {
            Size = UDim2.new(1, IsMobile and -110 or -130, 0, 14),
            Position = UDim2.new(0, IsMobile and 54 or 66, 0, IsMobile and 38 or 42),
            BackgroundTransparency = 1,
            Text = "From: " .. sourcesText,
            TextColor3 = Color3.fromRGB(150, 200, 150),
            TextSize = IsMobile and 8 or 9,
            Font = Enum.Font.Gotham,
            TextXAlignment = Enum.TextXAlignment.Left,
            TextTruncate = Enum.TextTruncate.AtEnd,
            ZIndex = 105,
            Parent = card
        })
        
        -- Toggle
        local toggleBg = CreateInstance("Frame", {
            Name = "ToggleBg",
            Size = UDim2.new(0, IsMobile and 44 or 54, 0, IsMobile and 24 or 28),
            Position = UDim2.new(1, IsMobile and -52 or -64, 0.5, IsMobile and -12 or -14),
            BackgroundColor3 = isEnabled and Theme.Success or Theme.BackgroundTertiary,
            BackgroundTransparency = 0.4,
            ZIndex = 105,
            Parent = card
        })
        AddCorner(toggleBg, 14)
        AddStroke(toggleBg, isEnabled and Theme.Success or Theme.Border, 1)
        
        local toggleCircle = CreateInstance("Frame", {
            Name = "Circle",
            Size = UDim2.new(0, IsMobile and 18 or 22, 0, IsMobile and 18 or 22),
            Position = isEnabled 
                and UDim2.new(1, IsMobile and -21 or -25, 0.5, IsMobile and -9 or -11)
                or UDim2.new(0, 3, 0.5, IsMobile and -9 or -11),
            BackgroundColor3 = Theme.TextPrimary,
            ZIndex = 106,
            Parent = toggleBg
        })
        AddCorner(toggleCircle, 11)
        
        self.oreCards[ore.Name] = {Card = card, ToggleBg = toggleBg, Circle = toggleCircle}
        
        -- Click handler
        local debounce = false
        card.InputBegan:Connect(function(input)
            if debounce then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                debounce = true
                
                local newState = not OreFarmSelection[ore.Name]
                OreFarmSelection[ore.Name] = newState
                
                Tween(toggleBg, {BackgroundColor3 = newState and Theme.Success or Theme.BackgroundTertiary}, 0.2)
                Tween(toggleCircle, {
                    Position = newState 
                        and UDim2.new(1, IsMobile and -21 or -25, 0.5, IsMobile and -9 or -11)
                        or UDim2.new(0, 3, 0.5, IsMobile and -9 or -11)
                }, 0.2)
                
                local stroke = toggleBg:FindFirstChildOfClass("UIStroke")
                if stroke then Tween(stroke, {Color = newState and Theme.Success or Theme.Border}, 0.2) end
                
                UpdateCount()
                task.wait(0.15)
                debounce = false
            end
        end)
    end
    
    -- Apply button - calculates sources and applies
    applyBtn.MouseButton1Click:Connect(function()
        local sources = CalculateRequiredSources()
        Config.SelectedSources = sources
        
        -- Also update SelectedOres for reference
        local ores = {}
        for name, enabled in pairs(OreFarmSelection) do
            if enabled then table.insert(ores, name) end
        end
        Config.SelectedOres = ores
        
        if #sources > 0 then
            ShowToast(string.format("Mining %d rock types for %d ores!", #sources, #ores), "success")
        else
            ShowToast("No sources to mine!", "warning")
        end
    end)
    
    selectAllBtn.MouseButton1Click:Connect(function()
        for _, ore in ipairs(OreDatabase) do
            if not ore.Name:find("Essence") and ore.Rarity ~= "Divine" and ore.Rarity ~= "Relic" then
                OreFarmSelection[ore.Name] = true
                local cardData = self.oreCards[ore.Name]
                if cardData then
                    Tween(cardData.ToggleBg, {BackgroundColor3 = Theme.Success}, 0.2)
                    Tween(cardData.Circle, {Position = UDim2.new(1, IsMobile and -21 or -25, 0.5, IsMobile and -9 or -11)}, 0.2)
                    local stroke = cardData.ToggleBg:FindFirstChildOfClass("UIStroke")
                    if stroke then Tween(stroke, {Color = Theme.Success}, 0.2) end
                end
            end
        end
        UpdateCount()
    end)
    
    deselectAllBtn.MouseButton1Click:Connect(function()
        for _, ore in ipairs(OreDatabase) do
            OreFarmSelection[ore.Name] = false
            local cardData = self.oreCards[ore.Name]
            if cardData then
                Tween(cardData.ToggleBg, {BackgroundColor3 = Theme.BackgroundTertiary}, 0.2)
                Tween(cardData.Circle, {Position = UDim2.new(0, 3, 0.5, IsMobile and -9 or -11)}, 0.2)
                local stroke = cardData.ToggleBg:FindFirstChildOfClass("UIStroke")
                if stroke then Tween(stroke, {Color = Theme.Border}, 0.2) end
            end
        end
        UpdateCount()
    end)
    
    -- Dragging
    local isDragging = false
    local dragStartPos, frameStartPos
    
    header.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
            dragStartPos = input.Position
            frameStartPos = self.mainFrame.Position
            
            if self.dragConnection then self.dragConnection:Disconnect() end
            self.dragConnection = UserInputService.InputChanged:Connect(function(moveInput)
                if isDragging and self.mainFrame and dragStartPos and frameStartPos then
                    if moveInput.UserInputType == Enum.UserInputType.MouseMovement or moveInput.UserInputType == Enum.UserInputType.Touch then
                        local delta = moveInput.Position - dragStartPos
                        self.mainFrame.Position = UDim2.new(
                            frameStartPos.X.Scale, frameStartPos.X.Offset + delta.X,
                            frameStartPos.Y.Scale, frameStartPos.Y.Offset + delta.Y
                        )
                    end
                end
            end)
        end
    end)
    
    header.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = false
            if self.dragConnection then self.dragConnection:Disconnect(); self.dragConnection = nil end
        end
    end)
    
    UpdateCount()
end

function OreManagerUI:Close()
    if not self.isOpen then return end
    self.isOpen = false
    
    if self.dragConnection then self.dragConnection:Disconnect(); self.dragConnection = nil end
    if self.dragEndConnection then self.dragEndConnection:Disconnect(); self.dragEndConnection = nil end
    
    local overlay = ScreenGui:FindFirstChild("OreManagerOverlay")
    if overlay then
        Tween(overlay, {BackgroundTransparency = 1}, 0.2)
        task.delay(0.25, function() if overlay then overlay:Destroy() end end)
    end
    
    if self.mainFrame then
        Tween(self.mainFrame, {Size = UDim2.new(0, 0, 0, 0)}, 0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In)
        task.delay(0.25, function()
            if self.mainFrame then self.mainFrame:Destroy(); self.mainFrame = nil end
        end)
    end
    
    table.clear(self.oreCards)
    
    -- Auto-apply on close
    local sources = CalculateRequiredSources()
    Config.SelectedSources = sources
    
    local ores = {}
    for name, enabled in pairs(OreFarmSelection) do
        if enabled then table.insert(ores, name) end
    end
    Config.SelectedOres = ores
    
    ShowToast(string.format("Will mine: %d source rocks", #sources), "info")
end

--// ============================================================
--// MONSTER MANAGER UI (Farm Monster Selection)
--// ============================================================

local MonsterFarmSelection = {}
local MonsterDatabase = {} -- Will be populated from Index

local MonsterManagerUI = {
    isOpen = false,
    mainFrame = nil :: Frame?,
    monsterCards = {},
    dragConnection = nil,
    dragEndConnection = nil,
}

-- Get monster icon from Index
local function CloneMonsterIcon(monsterName, listName)
    local success, result = pcall(function()
        local enemiesFolder = player.PlayerGui.Menu.Frame.Frame.Menus.Index.Pages.Enemies.ScrollingFrame
        local list = enemiesFolder:FindFirstChild(listName)
        if list then
            local monsterEntry = list:FindFirstChild(monsterName)
            if monsterEntry then
                local main = monsterEntry:FindFirstChild("Main")
                if main then
                    local icon = main:FindFirstChild("ItemIcon")
                    if icon then return icon:Clone() end
                end
            end
        end
        return nil
    end)
    return success and result or nil
end

-- Scan monsters from Index
local function ScanMonstersFromIndex()
    local monsters = {}
    local monsterLists = {"Forgotten Kingdom List", "Goblin Cave List", "Iron Valley List"}
    
    local success = pcall(function()
        local enemiesFolder = player.PlayerGui.Menu.Frame.Frame.Menus.Index.Pages.Enemies.ScrollingFrame
        for _, listName in ipairs(monsterLists) do
            local list = enemiesFolder:FindFirstChild(listName)
            if list then
                for _, monster in ipairs(list:GetChildren()) do
                    if monster:IsA("Frame") or monster:IsA("ImageButton") then
                        local main = monster:FindFirstChild("Main")
                        if main then
                            table.insert(monsters, {
                                Name = monster.Name,
                                List = listName,
                                Map = listName:gsub(" List", "")
                            })
                        end
                    end
                end
            end
        end
    end)
    
    return monsters
end

function MonsterManagerUI:Open()
    if self.isOpen then return end
    self.isOpen = true
    
    -- Scan monsters
    MonsterDatabase = ScanMonstersFromIndex()
    
    -- Initialize selection if empty
    for _, monster in ipairs(MonsterDatabase) do
        if MonsterFarmSelection[monster.Name] == nil then
            MonsterFarmSelection[monster.Name] = true
        end
    end
    
    local targetSize = IsMobile and UDim2.new(0, 360, 0, 480) or UDim2.new(0, 480, 0, 580)
    
    local overlay = CreateInstance("Frame", {
        Name = "MonsterManagerOverlay",
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundColor3 = Color3.fromRGB(0, 0, 0),
        BackgroundTransparency = 1,
        ZIndex = 100,
        Active = true,
        Parent = ScreenGui
    })
    
    self.mainFrame = CreateInstance("Frame", {
        Name = "MonsterManagerFrame",
        Size = targetSize,
        Position = UDim2.new(0.5, 0, 0.5, 0),
        AnchorPoint = Vector2.new(0.5, 0.5),
        BackgroundColor3 = Theme.Background,
        BackgroundTransparency = 0.7,
        ZIndex = 101,
        Active = true,
        Parent = ScreenGui
    })
    AddCorner(self.mainFrame, 16)
    AddStroke(self.mainFrame, Color3.fromRGB(255, 100, 100), 2)
    
    self.mainFrame.Size = UDim2.new(0, 0, 0, 0)
    Tween(self.mainFrame, {Size = targetSize}, 0.4, Enum.EasingStyle.Back)
    Tween(overlay, {BackgroundTransparency = 0.5}, 0.3)
    
    -- Header
    local header = CreateInstance("Frame", {
        Size = UDim2.new(1, 0, 0, IsMobile and 55 or 65),
        BackgroundColor3 = Theme.BackgroundSecondary,
        BackgroundTransparency = 0.6,
        ZIndex = 102,
        Active = true,
        Parent = self.mainFrame
    })
    AddCorner(header, 16)
    
    CreateInstance("ImageLabel", {
        Size = UDim2.new(0, IsMobile and 22 or 26, 0, IsMobile and 22 or 26),
        Position = UDim2.new(0, 12, 0, IsMobile and 8 or 12),
        BackgroundTransparency = 1,
        Image = "rbxassetid://123680618370738",
        ImageColor3 = Color3.fromRGB(255, 100, 100),
        ZIndex = 103,
        Parent = header
    })
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, -80, 0, 24),
        Position = UDim2.new(0, IsMobile and 38 or 44, 0, IsMobile and 8 or 12),
        BackgroundTransparency = 1,
        Text = "MONSTER MANAGER",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 18 or 22,
        Font = Enum.Font.GothamBlack,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 103,
        Parent = header
    })
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, -60, 0, 16),
        Position = UDim2.new(0, IsMobile and 38 or 44, 0, IsMobile and 32 or 38),
        BackgroundTransparency = 1,
        Text = "Toggle monsters to farm",
        TextColor3 = Theme.TextSecondary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.Gotham,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 103,
        Parent = header
    })
    
    local closeBtn = CreateInstance("TextButton", {
        Size = UDim2.new(0, IsMobile and 36 or 42, 0, IsMobile and 36 or 42),
        Position = UDim2.new(1, IsMobile and -44 or -52, 0.5, IsMobile and -18 or -21),
        BackgroundColor3 = Theme.Error,
        BackgroundTransparency = 0.4,
        Text = "X",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 16 or 18,
        Font = Enum.Font.GothamBold,
        ZIndex = 103,
        Parent = header
    })
    AddCorner(closeBtn, 10)
    
    closeBtn.MouseButton1Click:Connect(function()
        self:Close()
    end)
    
    -- Stats bar
    local statsBar = CreateInstance("Frame", {
        Size = UDim2.new(1, -20, 0, IsMobile and 40 or 48),
        Position = UDim2.new(0, 10, 0, IsMobile and 60 or 72),
        BackgroundColor3 = Theme.BackgroundTertiary,
        BackgroundTransparency = 0.5,
        ZIndex = 102,
        Active = true,
        Parent = self.mainFrame
    })
    AddCorner(statsBar, 10)
    
    local selectedLabel = CreateInstance("TextLabel", {
        Name = "SelectedLabel",
        Size = UDim2.new(0.5, 0, 1, 0),
        Position = UDim2.new(0, 10, 0, 0),
        BackgroundTransparency = 1,
        Text = "Selected: 0/0",
        TextColor3 = Color3.fromRGB(255, 100, 100),
        TextSize = IsMobile and 12 or 14,
        Font = Enum.Font.GothamBold,
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 103,
        Parent = statsBar
    })
    
    local selectAllBtn = CreateInstance("TextButton", {
        Size = UDim2.new(0, IsMobile and 50 or 65, 0, IsMobile and 26 or 32),
        Position = UDim2.new(1, IsMobile and -110 or -145, 0.5, IsMobile and -13 or -16),
        BackgroundColor3 = Theme.Success,
        BackgroundTransparency = 0.4,
        Text = "All",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.GothamBold,
        ZIndex = 103,
        Parent = statsBar
    })
    AddCorner(selectAllBtn, 6)
    
    local deselectAllBtn = CreateInstance("TextButton", {
        Size = UDim2.new(0, IsMobile and 50 or 65, 0, IsMobile and 26 or 32),
        Position = UDim2.new(1, IsMobile and -55 or -72, 0.5, IsMobile and -13 or -16),
        BackgroundColor3 = Theme.Error,
        BackgroundTransparency = 0.4,
        Text = "None",
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.GothamBold,
        ZIndex = 103,
        Parent = statsBar
    })
    AddCorner(deselectAllBtn, 6)
    
    -- Monster list
    local listContainer = CreateInstance("Frame", {
        Size = UDim2.new(1, -20, 1, IsMobile and -150 or -175),
        Position = UDim2.new(0, 10, 0, IsMobile and 105 or 127),
        BackgroundColor3 = Theme.BackgroundSecondary,
        BackgroundTransparency = 0.6,
        ClipsDescendants = true,
        ZIndex = 102,
        Active = true,
        Parent = self.mainFrame
    })
    AddCorner(listContainer, 12)
    
    local monsterList = CreateInstance("ScrollingFrame", {
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundTransparency = 1,
        ScrollBarThickness = 4,
        ScrollBarImageColor3 = Color3.fromRGB(255, 100, 100),
        CanvasSize = UDim2.new(0, 0, 0, 0),
        AutomaticCanvasSize = Enum.AutomaticSize.Y,
        ZIndex = 103,
        Active = true,
        Parent = listContainer
    })
    
    CreateInstance("UIListLayout", {
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 5),
        Parent = monsterList
    })
    AddPadding(monsterList, 6, 6, 6, 6)
    
    local function UpdateCount()
        local selected = 0
        for _, v in pairs(MonsterFarmSelection) do
            if v then selected += 1 end
        end
        selectedLabel.Text = string.format("Selected: %d/%d", selected, #MonsterDatabase)
    end
    
    -- Create monster cards
    if #MonsterDatabase == 0 then
        CreateInstance("TextLabel", {
            Size = UDim2.new(1, -20, 0, 60),
            BackgroundTransparency = 1,
            Text = "Open Index > Enemies first\nto load monster data",
            TextColor3 = Theme.TextSecondary,
            TextSize = 14,
            Font = Enum.Font.Gotham,
            ZIndex = 104,
            Parent = monsterList
        })
    end
    
    for i, monster in pairs(MonsterDatabase) do
        local isEnabled = MonsterFarmSelection[monster.Name] ~= false
        
        local card = CreateInstance("Frame", {
            Name = monster.Name,
            Size = UDim2.new(1, 0, 0, IsMobile and 52 or 62),
            BackgroundColor3 = Theme.CardBackground,
            BackgroundTransparency = 0.5,
            LayoutOrder = i,
            ZIndex = 104,
            Active = true,
            Parent = monsterList
        })
        AddCorner(card, 8)
        AddStroke(card, Theme.Border, 1)
        
        -- Red accent
        CreateInstance("Frame", {
            Size = UDim2.new(0, 3, 1, -8),
            Position = UDim2.new(0, 4, 0, 4),
            BackgroundColor3 = Color3.fromRGB(255, 100, 100),
            ZIndex = 105,
            Parent = card
        })
        
        -- Icon
        local iconBg = CreateInstance("Frame", {
            Size = UDim2.new(0, IsMobile and 36 or 44, 0, IsMobile and 36 or 44),
            Position = UDim2.new(0, 12, 0.5, IsMobile and -18 or -22),
            BackgroundColor3 = Color3.fromRGB(60, 60, 60),
            BackgroundTransparency = 0.5,
            ClipsDescendants = true,
            ZIndex = 105,
            Parent = card
        })
        AddCorner(iconBg, 8)
        
        local realIcon = CloneMonsterIcon(monster.Name, monster.List)
        if realIcon then
            realIcon.Size = UDim2.new(0.9, 0, 0.9, 0)
            realIcon.Position = UDim2.new(0.5, 0, 0.5, 0)
            realIcon.AnchorPoint = Vector2.new(0.5, 0.5)
            realIcon.ZIndex = 106
            realIcon.Parent = iconBg
        else
            CreateInstance("TextLabel", {
                Size = UDim2.new(1, 0, 1, 0),
                BackgroundTransparency = 1,
                Text = monster.Name:sub(1, 2):upper(),
                TextColor3 = Color3.fromRGB(255, 100, 100),
                TextSize = IsMobile and 14 or 18,
                Font = Enum.Font.GothamBlack,
                ZIndex = 106,
                Parent = iconBg
            })
        end
        
        -- Monster name
        CreateInstance("TextLabel", {
            Size = UDim2.new(1, IsMobile and -110 or -130, 0, 20),
            Position = UDim2.new(0, IsMobile and 54 or 66, 0, IsMobile and 6 or 8),
            BackgroundTransparency = 1,
            Text = monster.Name,
            TextColor3 = Theme.TextPrimary,
            TextSize = IsMobile and 12 or 14,
            Font = Enum.Font.GothamBold,
            TextXAlignment = Enum.TextXAlignment.Left,
            TextTruncate = Enum.TextTruncate.AtEnd,
            ZIndex = 105,
            Parent = card
        })
        
        -- Map info
        CreateInstance("TextLabel", {
            Size = UDim2.new(1, IsMobile and -110 or -130, 0, 16),
            Position = UDim2.new(0, IsMobile and 54 or 66, 0, IsMobile and 26 or 30),
            BackgroundTransparency = 1,
            Text = monster.Map,
            TextColor3 = Theme.TextSecondary,
            TextSize = IsMobile and 9 or 11,
            Font = Enum.Font.Gotham,
            TextXAlignment = Enum.TextXAlignment.Left,
            ZIndex = 105,
            Parent = card
        })
        
        -- Toggle
        local toggleBg = CreateInstance("Frame", {
            Name = "ToggleBg",
            Size = UDim2.new(0, IsMobile and 44 or 54, 0, IsMobile and 24 or 28),
            Position = UDim2.new(1, IsMobile and -52 or -64, 0.5, IsMobile and -12 or -14),
            BackgroundColor3 = isEnabled and Theme.Success or Theme.BackgroundTertiary,
            BackgroundTransparency = 0.4,
            ZIndex = 105,
            Parent = card
        })
        AddCorner(toggleBg, 14)
        AddStroke(toggleBg, isEnabled and Theme.Success or Theme.Border, 1)
        
        local toggleCircle = CreateInstance("Frame", {
            Name = "Circle",
            Size = UDim2.new(0, IsMobile and 18 or 22, 0, IsMobile and 18 or 22),
            Position = isEnabled 
                and UDim2.new(1, IsMobile and -21 or -25, 0.5, IsMobile and -9 or -11)
                or UDim2.new(0, 3, 0.5, IsMobile and -9 or -11),
            BackgroundColor3 = Theme.TextPrimary,
            ZIndex = 106,
            Parent = toggleBg
        })
        AddCorner(toggleCircle, 11)
        
        self.monsterCards[monster.Name] = {Card = card, ToggleBg = toggleBg, Circle = toggleCircle}
        
        -- Click handler
        local debounce = false
        card.InputBegan:Connect(function(input)
            if debounce then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                debounce = true
                
                local newState = not MonsterFarmSelection[monster.Name]
                MonsterFarmSelection[monster.Name] = newState
                
                Tween(toggleBg, {BackgroundColor3 = newState and Theme.Success or Theme.BackgroundTertiary}, 0.2)
                Tween(toggleCircle, {
                    Position = newState 
                        and UDim2.new(1, IsMobile and -21 or -25, 0.5, IsMobile and -9 or -11)
                        or UDim2.new(0, 3, 0.5, IsMobile and -9 or -11)
                }, 0.2)
                
                local stroke = toggleBg:FindFirstChildOfClass("UIStroke")
                if stroke then Tween(stroke, {Color = newState and Theme.Success or Theme.Border}, 0.2) end
                
                UpdateCount()
                task.wait(0.15)
                debounce = false
            end
        end)
    end
    
    selectAllBtn.MouseButton1Click:Connect(function()
        for _, monster in ipairs(MonsterDatabase) do
            MonsterFarmSelection[monster.Name] = true
            local cardData = self.monsterCards[monster.Name]
            if cardData then
                Tween(cardData.ToggleBg, {BackgroundColor3 = Theme.Success}, 0.2)
                Tween(cardData.Circle, {Position = UDim2.new(1, IsMobile and -21 or -25, 0.5, IsMobile and -9 or -11)}, 0.2)
                local stroke = cardData.ToggleBg:FindFirstChildOfClass("UIStroke")
                if stroke then Tween(stroke, {Color = Theme.Success}, 0.2) end
            end
        end
        UpdateCount()
        ShowToast("All monsters enabled!", "success")
    end)
    
    deselectAllBtn.MouseButton1Click:Connect(function()
        for _, monster in ipairs(MonsterDatabase) do
            MonsterFarmSelection[monster.Name] = false
            local cardData = self.monsterCards[monster.Name]
            if cardData then
                Tween(cardData.ToggleBg, {BackgroundColor3 = Theme.BackgroundTertiary}, 0.2)
                Tween(cardData.Circle, {Position = UDim2.new(0, 3, 0.5, IsMobile and -9 or -11)}, 0.2)
                local stroke = cardData.ToggleBg:FindFirstChildOfClass("UIStroke")
                if stroke then Tween(stroke, {Color = Theme.Border}, 0.2) end
            end
        end
        UpdateCount()
        ShowToast("All monsters disabled!", "warning")
    end)
    
    -- Dragging
    local isDragging = false
    local dragStartPos, frameStartPos
    
    header.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
            dragStartPos = input.Position
            frameStartPos = self.mainFrame.Position
            
            if self.dragConnection then self.dragConnection:Disconnect() end
            self.dragConnection = UserInputService.InputChanged:Connect(function(moveInput)
                if isDragging and self.mainFrame and dragStartPos and frameStartPos then
                    if moveInput.UserInputType == Enum.UserInputType.MouseMovement or moveInput.UserInputType == Enum.UserInputType.Touch then
                        local delta = moveInput.Position - dragStartPos
                        self.mainFrame.Position = UDim2.new(
                            frameStartPos.X.Scale, frameStartPos.X.Offset + delta.X,
                            frameStartPos.Y.Scale, frameStartPos.Y.Offset + delta.Y
                        )
                    end
                end
            end)
        end
    end)
    
    header.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = false
            if self.dragConnection then self.dragConnection:Disconnect(); self.dragConnection = nil end
        end
    end)
    
    UpdateCount()
end

function MonsterManagerUI:Close()
    if not self.isOpen then return end
    self.isOpen = false
    
    if self.dragConnection then self.dragConnection:Disconnect(); self.dragConnection = nil end
    if self.dragEndConnection then self.dragEndConnection:Disconnect(); self.dragEndConnection = nil end
    
    local overlay = ScreenGui:FindFirstChild("MonsterManagerOverlay")
    if overlay then
        Tween(overlay, {BackgroundTransparency = 1}, 0.2)
        task.delay(0.25, function() if overlay then overlay:Destroy() end end)
    end
    
    if self.mainFrame then
        Tween(self.mainFrame, {Size = UDim2.new(0, 0, 0, 0)}, 0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In)
        task.delay(0.25, function()
            if self.mainFrame then self.mainFrame:Destroy(); self.mainFrame = nil end
        end)
    end
    
    table.clear(self.monsterCards)
    
    -- Apply selection to Config
    local selected = {}
    for name, enabled in pairs(MonsterFarmSelection) do
        if enabled then table.insert(selected, name) end
    end
    Config.SelectedMonsters = selected
    ShowToast(string.format("Monster Manager: %d monsters selected", #selected), "info")
end

--// ============================================================
--// MOVEMENT CONTROLLER
--// ============================================================

local MovementController = {
    attachment = nil :: Attachment?,
    linearVelocity = nil :: LinearVelocity?,
    alignOrientation = nil :: AlignOrientation?,
    positionSpring = nil :: Spring?,
    isActive = false,
    isMoving = false,
    targetPosition = nil :: Vector3?,
    onCompleteCallback = nil :: ((boolean) -> ())?,
    lastPosition = nil :: Vector3?,
    lastPositionTime = 0,
    tpDetectedCount = 0,
    tpCooldownUntil = 0,
    isPaused = false,
    slowModeUntil = 0,
    currentSpeedMultiplier = 1,
    needsEscapeRise = false,
    updateConnection = nil :: Connection?,
    noclipConnection = nil :: Connection?,
    antiTpConnection = nil :: Connection?,
    OnTeleportDetected = Signal.new(),
    OnMovementComplete = Signal.new(),
    OnMovementStarted = Signal.new(),
}

function MovementController:GetCharacterParts(): (Model?, BasePart?, Humanoid?)
    local character = player.Character
    if not character then return nil, nil, nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart") :: BasePart?
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    
    return character, hrp, humanoid
end

function MovementController:CleanupPhysics()
    if self.attachment then
        self.attachment:Destroy()
        self.attachment = nil
    end
    
    if self.linearVelocity then
        self.linearVelocity:Destroy()
        self.linearVelocity = nil
    end
    
    if self.alignOrientation then
        self.alignOrientation:Destroy()
        self.alignOrientation = nil
    end
    
    self.positionSpring = nil
end

function MovementController:InitializePhysics(): boolean
    local character, hrp, humanoid = self:GetCharacterParts()
    if not character or not hrp or not humanoid then
        return false
    end
    
    self:CleanupPhysics()
    
    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    
    self.attachment = Instance.new("Attachment")
    self.attachment.Name = "ForgeMovementAttachment"
    self.attachment.Parent = hrp
    
    self.linearVelocity = Instance.new("LinearVelocity")
    self.linearVelocity.Name = "ForgeLinearVelocity"
    self.linearVelocity.Attachment0 = self.attachment
    self.linearVelocity.MaxForce = math.huge
    self.linearVelocity.VectorVelocity = Vector3.zero
    self.linearVelocity.RelativeTo = Enum.ActuatorRelativeTo.World
    self.linearVelocity.Parent = hrp
    
    self.alignOrientation = Instance.new("AlignOrientation")
    self.alignOrientation.Name = "ForgeAlignOrientation"
    self.alignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
    self.alignOrientation.Attachment0 = self.attachment
    self.alignOrientation.MaxTorque = math.huge
    self.alignOrientation.Responsiveness = Config.RotationResponsiveness
    self.alignOrientation.CFrame = hrp.CFrame
    self.alignOrientation.Parent = hrp
    
    self.positionSpring = SpringClass.new(hrp.Position, Config.MovementDamping, Config.MovementSpeed)
    
    self.isActive = true
    return true
end

function MovementController:StartAntiTpMonitor()
    if self.antiTpConnection then return end
    
    local _, hrp, _ = self:GetCharacterParts()
    if not hrp then return end
    
    self.lastPosition = hrp.Position
    self.lastPositionTime = tick()
    self.tpDetectedCount = 0
    self.tpCooldownUntil = 0
    self.isPaused = false
    self.slowModeUntil = 0
    self.currentSpeedMultiplier = 1
    
    self.antiTpConnection = TrackConnection(RunService.Heartbeat:Connect(function()
        if not Config.AntiTpEnabled or State.isClosing then
            return
        end
        
        local _, root, _ = self:GetCharacterParts()
        if not root then return end
        
        local currentPos = root.Position
        local currentTime = tick()
        
        if currentTime > self.slowModeUntil then
            self.currentSpeedMultiplier = math.min(self.currentSpeedMultiplier + 0.01, 1)
        end
        
        if currentTime < self.tpCooldownUntil then
            self.isPaused = true
            return
        else
            self.isPaused = false
        end
        
        if self.lastPosition and self.isMoving then
            local distance = (currentPos - self.lastPosition).Magnitude
            local timeDiff = currentTime - self.lastPositionTime
            
            if timeDiff < 0.5 and distance > Config.AntiTpThreshold then
                self.tpDetectedCount += 1
                self:Stop()
                self.needsEscapeRise = true
                self.currentSpeedMultiplier = 0.3
                self.slowModeUntil = currentTime + 5
                
                self.OnTeleportDetected:Fire(distance)
                ShowToast("Anti-TP: Detected!", "warning")
                
                if self.tpDetectedCount >= Config.AntiTpMaxStrikes then
                    self:HoldPosition()
                    self.isPaused = true
                    self.tpCooldownUntil = currentTime + Config.AntiTpLongPause
                    self.tpDetectedCount = 0
                    ShowToast("Anti-TP: Hard pause", "error")
                    
                    task.delay(Config.AntiTpLongPause, function()
                        if not State.isClosing then
                            self.isPaused = false
                            self.currentSpeedMultiplier = 0.5
                            self.needsEscapeRise = true
                        end
                    end)
                end
            end
        end
        
        self.lastPosition = currentPos
        self.lastPositionTime = currentTime
    end))
end

function MovementController:StopAntiTpMonitor()
    if self.antiTpConnection then
        self.antiTpConnection:Disconnect()
        self.antiTpConnection = nil
    end
    
    self.isPaused = false
    self.tpDetectedCount = 0
    self.currentSpeedMultiplier = 1
    self.slowModeUntil = 0
end

function MovementController:EnableNoclip()
    if self.noclipConnection then return end
    
    self.noclipConnection = TrackConnection(RunService.Stepped:Connect(function()
        if State.isClosing then
            self:DisableNoclip()
            return
        end
        
        local character = player.Character
        if not character then return end
        
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
        
        if State.isAutoKilling then
            local livingFolder = Workspace:FindFirstChild("Living")
            if livingFolder then
                local _, hrp, _ = self:GetCharacterParts()
                if hrp then
                    local myPos = hrp.Position
                    for _, entity in ipairs(livingFolder:GetChildren()) do
                        if entity:IsA("Model") and entity:GetAttribute("IsNpc") == true then
                            local entityPos = entity:GetPivot().Position
                            if (myPos - entityPos).Magnitude < 20 then
                                for _, part in ipairs(entity:GetDescendants()) do
                                    if part:IsA("BasePart") then
                                        part.CanCollide = false
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end))
end

function MovementController:DisableNoclip()
    if self.noclipConnection then
        self.noclipConnection:Disconnect()
        self.noclipConnection = nil
    end
    
    local character = player.Character
    if character then
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = true
            end
        end
    end
end

function MovementController:MoveTo(targetPos: Vector3, speed: number?, onComplete: ((boolean) -> ())?)
    local _, hrp, humanoid = self:GetCharacterParts()
    if not hrp or not humanoid then
        if onComplete then onComplete(false) end
        return
    end
    
    if not self.linearVelocity or not self.linearVelocity.Parent then
        if not self:InitializePhysics() then
            if onComplete then onComplete(false) end
            return
        end
    end
    
    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    
    self.isMoving = true
    self.targetPosition = targetPos
    self.onCompleteCallback = onComplete
    
    if self.positionSpring then
        self.positionSpring.Position = hrp.Position
        self.positionSpring.Target = targetPos
        self.positionSpring.Velocity = Vector3.zero
    end
    
    self.OnMovementStarted:Fire(targetPos)
    
    if self.updateConnection then
        self.updateConnection:Disconnect()
    end
    
    local actualSpeed = math.max(speed or Config.MoveSpeed, 5)
    
    self.updateConnection = TrackConnection(RunService.Heartbeat:Connect(function(dt)
        if State.isClosing then
            self:Stop()
            if self.onCompleteCallback then
                self.onCompleteCallback(false)
                self.onCompleteCallback = nil
            end
            return
        end
        
        local _, currentHrp, _ = self:GetCharacterParts()
        if not currentHrp or not self.linearVelocity or not self.linearVelocity.Parent then
            self:Stop()
            if self.onCompleteCallback then
                self.onCompleteCallback(false)
                self.onCompleteCallback = nil
            end
            return
        end
        
        local currentPos = currentHrp.Position
        local direction = targetPos - currentPos
        local distance = direction.Magnitude
        
        if distance < 2 then
            self.linearVelocity.VectorVelocity = Vector3.zero
            self.isMoving = false
            
            if self.updateConnection then
                self.updateConnection:Disconnect()
                self.updateConnection = nil
            end
            
            self.OnMovementComplete:Fire(true)
            
            if self.onCompleteCallback then
                self.onCompleteCallback(true)
                self.onCompleteCallback = nil
            end
            return
        end
        
        if self.positionSpring then
            self.positionSpring.Target = targetPos
            local smoothPos = self.positionSpring:Update(dt)
            
            local toSpring = smoothPos - currentPos
            local springDist = toSpring.Magnitude
            
            if springDist > 0.1 then
                local moveSpeed = actualSpeed * self.currentSpeedMultiplier
                
                if distance < moveSpeed * 0.5 then
                    moveSpeed = math.max(distance * 2, 5)
                end
                
                self.linearVelocity.VectorVelocity = toSpring.Unit * moveSpeed
            else
                local moveDir = direction.Unit
                local moveSpeed = actualSpeed * self.currentSpeedMultiplier
                
                if distance < moveSpeed * 0.5 then
                    moveSpeed = math.max(distance * 2, 5)
                end
                
                self.linearVelocity.VectorVelocity = moveDir * moveSpeed
            end
        else
            local moveDir = direction.Unit
            local moveSpeed = actualSpeed * self.currentSpeedMultiplier
            
            if distance < moveSpeed * 0.5 then
                moveSpeed = math.max(distance * 2, 5)
            end
            
            self.linearVelocity.VectorVelocity = moveDir * moveSpeed
        end
    end))
end

function MovementController:FaceDirection(targetPos: Vector3)
    local _, hrp, _ = self:GetCharacterParts()
    if not hrp or not self.alignOrientation then return end
    
    local direction = targetPos - hrp.Position
    local horizontalDir = Vector3.new(direction.X, 0, direction.Z)
    
    if horizontalDir.Magnitude > 0.1 then
        self.alignOrientation.CFrame = CFrame.new(hrp.Position, hrp.Position + horizontalDir)
    end
end

function MovementController:FaceTarget(targetPos: Vector3)
    local _, hrp, _ = self:GetCharacterParts()
    if not hrp or not self.alignOrientation then return end
    
    local direction = targetPos - hrp.Position
    
    if direction.Magnitude > 0.1 then
        self.alignOrientation.CFrame = CFrame.new(hrp.Position, hrp.Position + direction.Unit)
    end
end

function MovementController:HoldPosition()
    if self.linearVelocity and self.linearVelocity.Parent then
        self.linearVelocity.VectorVelocity = Vector3.zero
    end
    self.isMoving = false
end

function MovementController:Stop()
    if self.updateConnection then
        self.updateConnection:Disconnect()
        self.updateConnection = nil
    end
    
    self:HoldPosition()
end

function MovementController:IsPaused(): boolean
    return self.isPaused or (tick() < self.tpCooldownUntil)
end

function MovementController:GetSpeedMultiplier(): number
    return self.currentSpeedMultiplier
end

function MovementController:NeedsEscapeRise(): boolean
    return self.needsEscapeRise == true
end

function MovementController:ClearEscapeRise()
    self.needsEscapeRise = false
end

function MovementController:PerformEscapeRise(callback: (() -> ())?)
    local _, hrp, _ = self:GetCharacterParts()
    if not hrp then
        self.needsEscapeRise = false
        if callback then callback() end
        return
    end
    
    ShowToast("Rising to safety...", "warning")
    
    local currentPos = hrp.Position
    local risePos = Vector3.new(currentPos.X, currentPos.Y + 200, currentPos.Z)
    
    self:MoveTo(risePos, Config.MoveSpeed, function(success)
        self.needsEscapeRise = false
        ShowToast("Safe! Resuming...", "success")
        if callback then callback() end
    end)
end

function MovementController:Cleanup()
    self:Stop()
    self:DisableNoclip()
    self:StopAntiTpMonitor()
    self:CleanupPhysics()
    self.isActive = false
    
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end
end

--// ============================================================
--// CRUISE ALTITUDE SYSTEM
--// ============================================================

local CruiseSystem = {
    isAtCruiseAltitude = false,
    cruiseHeight = Config.CruiseHeight,
    baseHeight = 0,
    targetCruiseY = 0,
}

function CruiseSystem:Initialize(): boolean
    local _, hrp, _ = MovementController:GetCharacterParts()
    if not hrp then return false end
    
    self.baseHeight = hrp.Position.Y
    self.targetCruiseY = self.baseHeight + self.cruiseHeight
    self.isAtCruiseAltitude = false
    
    return true
end

function CruiseSystem:GetCruisePosition(x: number, z: number): Vector3
    return Vector3.new(x, self.targetCruiseY, z)
end

function CruiseSystem:IsAtCruise(): boolean
    return self.isAtCruiseAltitude
end

function CruiseSystem:RiseToCruise(callback: ((boolean) -> ())?)
    local _, hrp, _ = MovementController:GetCharacterParts()
    if not hrp then
        if callback then callback(false) end
        return
    end
    
    ShowToast("Rising to cruise...", "info")
    
    local currentPos = hrp.Position
    local cruisePos = Vector3.new(currentPos.X, self.targetCruiseY, currentPos.Z)
    
    MovementController:MoveTo(cruisePos, Config.MoveSpeed, function(success)
        if success then
            self.isAtCruiseAltitude = true
            ShowToast("Farming started!", "success")
        end
        if callback then callback(success) end
    end)
end

function CruiseSystem:Reset()
    self.isAtCruiseAltitude = false
    self.baseHeight = 0
    self.targetCruiseY = 0
end

--// ============================================================
--// GAME SCANNING UTILITIES
--// ============================================================

local function ScanAllOres(): {string}
    local oreNames: {string} = {}
    local oreSet: {[string]: boolean} = {}
    
    local rocksFolder = Workspace:FindFirstChild("Rocks")
    if not rocksFolder then return oreNames end
    
    for _, mapFolder in ipairs(rocksFolder:GetChildren()) do
        if mapFolder:IsA("Model") or mapFolder:IsA("Folder") then
            for _, spawnLocation in ipairs(mapFolder:GetChildren()) do
                for _, ore in ipairs(spawnLocation:GetChildren()) do
                    if ore:IsA("Model") or ore:IsA("BasePart") then
                        local name = ore.Name
                        if not oreSet[name] then
                            oreSet[name] = true
                            table.insert(oreNames, name)
                        end
                    end
                end
            end
        end
    end
    
    table.sort(oreNames)
    return oreNames
end

local function ScanAllMonsters(): {string}
    local monsterNames: {string} = {}
    local monsterSet: {[string]: boolean} = {}
    
    local livingFolder = Workspace:FindFirstChild("Living")
    if not livingFolder then return monsterNames end
    
    for _, entity in ipairs(livingFolder:GetChildren()) do
        if entity:IsA("Model") then
            local isNpc = entity:GetAttribute("IsNpc")
            if isNpc == true then
                local baseName = entity.Name:gsub("%d+$", "")
                if baseName ~= "" and not monsterSet[baseName] then
                    monsterSet[baseName] = true
                    table.insert(monsterNames, baseName)
                end
            end
        end
    end
    
    table.sort(monsterNames)
    return monsterNames
end

--// ============================================================
--// ORE UTILITIES
--// ============================================================

local function GetBottomSurface(oreModel: Instance): (Vector3?, BasePart?)
    local parts: {BasePart} = {}
    
    local function scan(obj: Instance)
        for _, child in ipairs(obj:GetChildren()) do
            if child:IsA("BasePart") then
                table.insert(parts, child)
            end
            if child:IsA("Model") or child:IsA("Folder") then
                scan(child)
            end
        end
    end
    
    if oreModel:IsA("BasePart") then
        table.insert(parts, oreModel :: BasePart)
    end
    scan(oreModel)
    
    local lowestY = math.huge
    local bottomPart: BasePart? = nil
    
    for _, part in ipairs(parts) do
        local bottomY = part.Position.Y - part.Size.Y / 2
        if bottomY < lowestY then
            lowestY = bottomY
            bottomPart = part
        end
    end
    
    if bottomPart then
        return Vector3.new(bottomPart.Position.X, lowestY, bottomPart.Position.Z), bottomPart
    end
    
    local pivot = oreModel:GetPivot()
    return pivot.Position, nil
end

local function IsOreAlive(ore: Instance): boolean
    if not ore or not ore.Parent then return false end
    
    local health = ore:GetAttribute("Health")
    if health ~= nil and health <= 0 then
        return false
    end
    
    local healthValue = ore:FindFirstChild("Health")
    if healthValue and healthValue:IsA("NumberValue") then
        if healthValue.Value <= 0 then return false end
    end
    
    return ore.Parent ~= nil
end

local function IsOreAvailable(ore: Instance): boolean
    if not ore or not ore.Parent then return false end
    
    local health = ore:GetAttribute("Health")
    local maxHealth = ore:GetAttribute("MaxHealth")
    
    if health ~= nil and health <= 0 then
        return false
    end
    
    local lastHitPlayer = ore:GetAttribute("LastHitPlayer")
    
    if lastHitPlayer == nil or lastHitPlayer == "" then
        for _, child in ipairs(ore:GetDescendants()) do
            if child:IsA("BasePart") then
                local childLastHit = child:GetAttribute("LastHitPlayer")
                if childLastHit ~= nil and childLastHit ~= "" then
                    lastHitPlayer = childLastHit
                    break
                end
            end
        end
    end
    
    if lastHitPlayer == nil or lastHitPlayer == "" then
        if health and maxHealth and health < maxHealth then
            return false
        end
        return true
    end
    
    if lastHitPlayer == player.Name then
        return true
    end
    
    if health and maxHealth and health >= maxHealth then
        return true
    end
    
    return false
end

-- Get ore's current health
local function GetOreHealth(ore: Instance): number?
    if not ore then return nil end
    
    local health = ore:GetAttribute("Health")
    if health ~= nil then return health end
    
    local healthValue = ore:FindFirstChild("Health")
    if healthValue and healthValue:IsA("NumberValue") then
        return healthValue.Value
    end
    
    return nil
end

-- Blacklist for individual ores that can't be damaged (temporary, resets on new target cycle)
local UndamageableOres = {} :: {[Instance]: number}

-- SMART BLACKLIST: Blacklist entire rock TYPE when can't mine (clears on toggle)
local BlacklistedRockTypes = {} :: {[string]: boolean}

local function IsOreBlacklisted(ore: Instance): boolean
    local blacklistTime = UndamageableOres[ore]
    if blacklistTime then
        -- Blacklist expires after 30 seconds
        if tick() - blacklistTime < 30 then
            return true
        else
            UndamageableOres[ore] = nil
        end
    end
    return false
end

local function BlacklistOre(ore: Instance)
    UndamageableOres[ore] = tick()
end

-- Check if entire rock TYPE is blacklisted
local function IsRockTypeBlacklisted(rockName: string): boolean
    return BlacklistedRockTypes[rockName] == true
end

-- Blacklist entire rock TYPE (all rocks of this name)
local function BlacklistRockType(rockName: string)
    BlacklistedRockTypes[rockName] = true
    ShowToast(string.format("Can't mine %s, trying lower tier...", rockName), "warning")
end

-- Clear all rock type blacklists (called on toggle)
local function ClearRockTypeBlacklist()
    BlacklistedRockTypes = {}
end

--// ============================================================
--// MONSTER UTILITIES
--// ============================================================

local function IsMonsterAlive(monster: Instance): boolean
    if not monster or not monster.Parent then return false end
    
    local hum = monster:FindFirstChildOfClass("Humanoid")
    if hum then
        return hum.Health > 0
    end
    
    return false
end

local function GetMonsterPosition(monster: Instance): Vector3?
    local hrp = monster:FindFirstChild("HumanoidRootPart")
    if hrp and hrp:IsA("BasePart") then
        return hrp.Position
    end
    
    local primary = (monster :: Model).PrimaryPart
    if primary then
        return primary.Position
    end
    
    local part = monster:FindFirstChildWhichIsA("BasePart")
    if part then
        return part.Position
    end
    
    return monster:GetPivot().Position
end

--// ============================================================
--// TARGET FINDING
--// ============================================================

local function GetOtherPlayersPositions(): {Vector3}
    local positions: {Vector3} = {}
    
    if not Config.AvoidPlayerEnabled then
        return positions
    end
    
    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherHrp = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHrp and otherHrp:IsA("BasePart") then
                table.insert(positions, otherHrp.Position)
            end
        end
    end
    
    return positions
end

local function IsPositionNearOtherPlayer(position: Vector3, otherPlayersPositions: {Vector3}): boolean
    for _, otherPos in ipairs(otherPlayersPositions) do
        local dx = position.X - otherPos.X
        local dz = position.Z - otherPos.Z
        local horizontalDist = math.sqrt(dx * dx + dz * dz)
        
        if horizontalDist < Config.AvoidPlayerDistance then
            return true
        end
    end
    
    return false
end

-- Check if rock is available to mine (LastHitPlayer check)
local function CanMineRock(ore: Instance): boolean
    if not ore or not ore.Parent then return false end
    
    local health = ore:GetAttribute("Health")
    local maxHealth = ore:GetAttribute("MaxHealth")
    
    -- Dead ore
    if health ~= nil and health <= 0 then return false end
    
    -- Get LastHitPlayer from ore or its children
    local lastHitPlayer = ore:GetAttribute("LastHitPlayer")
    
    if lastHitPlayer == nil or lastHitPlayer == "" then
        -- Check children for LastHitPlayer
        for _, child in ipairs(ore:GetDescendants()) do
            if child:IsA("BasePart") then
                local childLastHit = child:GetAttribute("LastHitPlayer")
                if childLastHit ~= nil and childLastHit ~= "" then
                    lastHitPlayer = childLastHit
                    break
                end
            end
        end
    end
    
    -- No LastHitPlayer = free to mine
    if lastHitPlayer == nil or lastHitPlayer == "" then
        return true
    end
    
    -- LastHitPlayer is me = I can mine it
    if lastHitPlayer == player.Name then
        return true
    end
    
    -- LastHitPlayer is someone else...
    -- If health == maxHealth, it's reset, so we can mine
    if health and maxHealth and health >= maxHealth then
        return true
    end
    
    -- Someone else is mining it and health < maxHealth = skip!
    return false
end

-- Rock Priority System (lower = better)
-- Crystals -> Volcanic Rock -> Basalt Vein -> Basalt Core -> Basalt Rock -> Others
local RockPriority = {
    -- Crystals (highest priority = 1)
    ["Crimson Crystal"] = 1,
    ["Cyan Crystal"] = 1,
    ["Earth Crystal"] = 1,
    ["Light Crystal"] = 1,
    
    -- Volcanic Rock (priority 2)
    ["Volcanic Rock"] = 2,
    
    -- Basalt Vein (priority 3)
    ["Basalt Vein"] = 3,
    
    -- Basalt Core (priority 4)
    ["Basalt Core"] = 4,
    
    -- Basalt Rock (priority 5)
    ["Basalt Rock"] = 5,
    
    -- Basic rocks (lowest priority)
    ["Boulder"] = 6,
    ["Rock"] = 7,
    ["Pebble"] = 8,
    ["Lucky Block"] = 9,
}

local function GetRockPriority(oreName: string): number
    return RockPriority[oreName] or 10 -- Unknown rocks get lowest priority
end

local function FindNearestOre(preferHighestHealth: boolean?): (Instance?, number?)
    local _, hrp, _ = MovementController:GetCharacterParts()
    if not hrp then return nil, nil end
    
    local playerPos = hrp.Position
    local rocksFolder = Workspace:FindFirstChild("Rocks")
    if not rocksFolder then return nil, nil end
    
    CleanupOreCooldowns()
    
    local otherPlayersPositions = GetOtherPlayersPositions()
    
    -- Get target rocks to mine (from Ore Manager selection)
    local targetRocks = Config.SelectedSources
    local hasTargets = #targetRocks > 0
    
    -- Collect all valid ores with their data
    local validOres = {}
    
    -- Scan ALL rocks in the Rocks folder
    for _, child1 in ipairs(rocksFolder:GetChildren()) do
        for _, child2 in ipairs(child1:GetChildren()) do
            for _, ore in ipairs(child2:GetChildren()) do
                -- Basic checks
                if not (ore:IsA("Model") or ore:IsA("BasePart")) then continue end
                if not ore.Parent then continue end
                
                -- TARGET CHECK: Only mine rocks that are in SelectedSources!
                if hasTargets then
                    local isTarget = false
                    for _, targetName in ipairs(targetRocks) do
                        if ore.Name == targetName then
                            isTarget = true
                            break
                        end
                    end
                    if not isTarget then continue end -- Skip non-target rocks!
                end
                
                -- SMART BLACKLIST: Skip entire rock TYPE if blacklisted
                if IsRockTypeBlacklisted(ore.Name) then continue end
                
                -- Check if ore is alive
                local health = ore:GetAttribute("Health")
                if health ~= nil and health <= 0 then continue end
                
                -- Skip if on cooldown or blacklisted (individual)
                if IsOreOnCooldown(ore) then continue end
                if IsOreBlacklisted(ore) then continue end
                
                -- CHECK LASTHITPLAYER - Skip if someone else is mining!
                if not CanMineRock(ore) then continue end
                
                -- Get position
                local orePos
                pcall(function()
                    orePos = ore:GetPivot().Position
                end)
                if not orePos then continue end
                
                -- Skip goblin cave
                if IsInGoblinCaveDangerZone(orePos) or IsTooCloseToGoblinCave(orePos) then
                    continue
                end
                
                -- Skip if near other players
                if Config.AvoidPlayerEnabled and IsPositionNearOtherPlayer(orePos, otherPlayersPositions) then
                    continue
                end
                
                -- Calculate distance
                local dx = orePos.X - playerPos.X
                local dz = orePos.Z - playerPos.Z
                local dist = math.sqrt(dx * dx + dz * dz)
                
                -- Get rock priority
                local priority = GetRockPriority(ore.Name)
                
                -- Add to valid ores list
                table.insert(validOres, {
                    ore = ore,
                    health = health or 100,
                    maxHealth = ore:GetAttribute("MaxHealth") or 100,
                    distance = dist,
                    position = orePos,
                    priority = priority,
                    name = ore.Name,
                })
            end
        end
    end
    
    -- No valid ores found
    if #validOres == 0 then
        return nil, nil
    end
    
    -- PRIORITY-BASED SORTING (within selected targets):
    -- 1. Priority (Crystal > Volcanic > Basalt Vein > Basalt Core > Basalt Rock)
    -- 2. Within same priority: nearest first
    -- 3. Within same priority and distance: highest health
    
    table.sort(validOres, function(a, b)
        -- Different priority = use priority (lower = better)
        if a.priority ~= b.priority then
            return a.priority < b.priority
        end
        
        -- Same priority: check distance (within 200 studs range)
        local aClose = a.distance < 200
        local bClose = b.distance < 200
        
        -- One is close, one is far
        if aClose and not bClose then return true end
        if bClose and not aClose then return false end
        
        -- Both close or both far: prefer nearest
        if a.distance ~= b.distance then
            return a.distance < b.distance
        end
        
        -- Same distance: prefer highest health
        return a.health > b.health
    end)
    
    -- Return the best ore
    local best = validOres[1]
    return best.ore, best.distance
end

local function FindNearestMonster(): (Instance?, number?)
    local _, hrp, _ = MovementController:GetCharacterParts()
    if not hrp then return nil, nil end
    
    local playerPos = hrp.Position
    local nearestMonster: Instance? = nil
    local nearestDist = math.huge
    
    local livingFolder = Workspace:FindFirstChild("Living")
    if not livingFolder then return nil, nil end
    
    local otherPlayersPositions = GetOtherPlayersPositions()
    
    for _, entity in ipairs(livingFolder:GetChildren()) do
        if entity:IsA("Model") then
            local isNpc = entity:GetAttribute("IsNpc")
            if isNpc == true and IsMonsterAlive(entity) then
                local baseName = entity.Name:gsub("%d+$", "")
                
                local isSelected = false
                for _, selectedName in ipairs(Config.SelectedMonsters) do
                    if baseName == selectedName then
                        isSelected = true
                        break
                    end
                end
                
                if isSelected then
                    local monsterPos = GetMonsterPosition(entity)
                    if monsterPos then
                        if IsInGoblinCaveDangerZone(monsterPos) or IsTooCloseToGoblinCave(monsterPos) then
                            continue
                        end
                        
                        if IsPositionNearOtherPlayer(monsterPos, otherPlayersPositions) then
                            continue
                        end
                        
                        local dx = monsterPos.X - playerPos.X
                        local dz = monsterPos.Z - playerPos.Z
                        local dist = math.sqrt(dx * dx + dz * dz)
                        
                        if dist < nearestDist then
                            nearestDist = dist
                            nearestMonster = entity
                        end
                    end
                end
            end
        end
    end
    
    return nearestMonster, nearestDist
end

-- Find ANY nearby enemy within range (for Kill Nearby feature)
local function FindNearbyEnemy(maxRange: number): (Instance?, number?)
    local _, hrp, _ = MovementController:GetCharacterParts()
    if not hrp then return nil, nil end
    
    local playerPos = hrp.Position
    local nearestMonster: Instance? = nil
    local nearestDist = math.huge
    
    local livingFolder = Workspace:FindFirstChild("Living")
    if not livingFolder then return nil, nil end
    
    for _, entity in ipairs(livingFolder:GetChildren()) do
        if entity:IsA("Model") then
            local isNpc = entity:GetAttribute("IsNpc")
            if isNpc == true and IsMonsterAlive(entity) then
                local monsterPos = GetMonsterPosition(entity)
                if monsterPos then
                    local dx = monsterPos.X - playerPos.X
                    local dy = monsterPos.Y - playerPos.Y
                    local dz = monsterPos.Z - playerPos.Z
                    local dist = math.sqrt(dx * dx + dy * dy + dz * dz)
                    
                    -- Only consider enemies within range
                    if dist <= maxRange and dist < nearestDist then
                        nearestDist = dist
                        nearestMonster = entity
                    end
                end
            end
        end
    end
    
    return nearestMonster, nearestDist
end

local function GetNearestPlayerDistance(): (number, Vector3?)
    local _, hrp, _ = MovementController:GetCharacterParts()
    if not hrp then return math.huge, nil end
    
    local myPos = hrp.Position
    local nearestDist = math.huge
    local nearestPos: Vector3? = nil
    
    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherHrp = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHrp and otherHrp:IsA("BasePart") then
                local dx = myPos.X - otherHrp.Position.X
                local dz = myPos.Z - otherHrp.Position.Z
                local dist = math.sqrt(dx * dx + dz * dz)
                
                if dist < nearestDist then
                    nearestDist = dist
                    nearestPos = otherHrp.Position
                end
            end
        end
    end
    
    return nearestDist, nearestPos
end

--// ============================================================
--// AUTO SELL SYSTEM (FIXED - CONTINUOUS SELLING)
--// ============================================================

local AutoSellSystem = {
    loopRunning = false,
    lastSellTime = 0,
    totalSold = 0,
    
    OnSellComplete = Signal.new(),
    OnSellFailed = Signal.new(),
}

local function ShouldSkipItem(itemName: string?): boolean
    -- Nil/empty check
    if not itemName or itemName == "" then return true end
    if type(itemName) ~= "string" then return true end
    
    -- Trim whitespace
    itemName = itemName:match("^%s*(.-)%s*$") or itemName
    if itemName == "" then return true end
    
    -- Check against UI class names
    for _, uiName in ipairs(AutoSellConfig.UIClassNames) do
        if itemName == uiName then
            return true
        end
    end
    
    -- Check against protected items (tools, totems)
    for _, protected in ipairs(AutoSellConfig.ProtectedItems) do
        if itemName == protected then
            return true
        end
    end
    
    -- Check against patterns
    for _, pattern in ipairs(AutoSellConfig.UIPatterns) do
        if string.match(itemName, pattern) then
            return true
        end
    end
    
    -- Skip very short names (likely internal)
    if #itemName < 2 then return true end
    
    -- âš ï¸ CRITICAL: Check if this ore is DISABLED in Sell Manager
    -- If SellSelection[itemName] == false, skip it (don't sell)
    if SellSelection[itemName] == false then
        return true -- Skip = Don't sell this ore
    end
    
    return false
end

local function GetStashBackground(): (Frame?, string?)
    local success, result = pcall(function()
        local pGui = player:FindFirstChild("PlayerGui")
        if not pGui then return nil, "PlayerGui not found" end
        
        local menu = pGui:FindFirstChild("Menu")
        if not menu then return nil, "Menu not found" end
        
        local frame1 = menu:FindFirstChild("Frame")
        if not frame1 then return nil, "Frame1 not found" end
        
        local frame2 = frame1:FindFirstChild("Frame")
        if not frame2 then return nil, "Frame2 not found" end
        
        local menus = frame2:FindFirstChild("Menus")
        if not menus then return nil, "Menus not found" end
        
        local stash = menus:FindFirstChild("Stash")
        if not stash then return nil, "Stash not found" end
        
        local background = stash:FindFirstChild("Background")
        if not background then return nil, "Background not found" end
        
        return background, nil
    end)
    
    if not success then
        return nil, "Error: " .. tostring(result)
    end
    
    return result
end

local function GetStashItems(): {[string]: number}
    local items: {[string]: number} = {}
    
    local background, err = GetStashBackground()
    if not background then
        return items
    end
    
    -- Simple approach: child.Name IS the item name (like "Mushroomite", "Gold", "Lapis Lazuli")
    for _, child in ipairs(background:GetChildren()) do
        -- Get item name from child.Name directly
        local itemName = child.Name
        
        -- Skip non-GUI elements and layout elements
        if child:IsA("UIListLayout") or child:IsA("UIGridLayout") or child:IsA("UIPadding") or child:IsA("UICorner") then
            continue
        end
        
        -- Skip if not a valid container type
        if not (child:IsA("Frame") or child:IsA("ImageButton") or child:IsA("TextButton") or child:IsA("ImageLabel")) then
            continue
        end
        
        -- Skip filtered items (UI elements, protected items, disabled ores)
        if ShouldSkipItem(itemName) then
            continue
        end
        
        -- Get quantity - look for "x17" pattern in any TextLabel
        local quantity = 0
        
        for _, desc in ipairs(child:GetDescendants()) do
            if desc:IsA("TextLabel") or desc:IsA("TextBox") then
                local text = desc.Text or ""
                -- Match patterns like "x17", "X17", "x 17"
                local num = text:match("[xX]%s*(%d+)")
                if num then
                    quantity = tonumber(num) or 0
                    break
                end
            end
        end
        
        -- If no quantity found but item exists, assume 1
        if quantity == 0 then
            local hasContent = child:FindFirstChildWhichIsA("ImageLabel") 
                or child:FindFirstChildWhichIsA("ViewportFrame")
                or child:FindFirstChild("Main")
            if hasContent then
                quantity = 1
            end
        end
        
        -- Add to items if valid
        if quantity > 0 and itemName and #itemName > 0 then
            items[itemName] = (items[itemName] or 0) + quantity
        end
    end
    
    return items
end

-- Sanitize basket: Double-check all items are valid and quantities are integers
local function SanitizeBasket(rawItems: {[string]: number}): {[string]: number}
    local clean: {[string]: number} = {}
    
    for itemName, quantity in pairs(rawItems) do
        -- Skip if name is invalid
        if type(itemName) ~= "string" or itemName == "" then
            continue
        end
        
        -- Skip if should be filtered
        if ShouldSkipItem(itemName) then
            continue
        end
        
        -- Ensure quantity is a valid positive integer
        local qty = tonumber(quantity)
        if not qty or qty < 1 then
            continue
        end
        
        -- Store with integer quantity
        clean[itemName] = math.floor(qty)
    end
    
    return clean
end

local function SellItems(itemsToSell: {[string]: number}): (boolean, string?, number)
    -- First, sanitize the basket
    local cleanBasket = SanitizeBasket(itemsToSell)
    
    -- Check if basket is empty after sanitization
    if not cleanBasket or not next(cleanBasket) then
        return false, "Basket empty after sanitization", 0
    end
    
    -- Count total quantity
    local totalQuantity = 0
    for _, qty in ipairs(cleanBasket) do
        totalQuantity += qty
    end
    
    if totalQuantity < AutoSellConfig.MinItemsToSell then
        return false, "Not enough items", 0
    end
    
    -- Use EXACT format from working script (NO PCALL!)
    local args = {
        "SellConfirm",
        {
            Basket = cleanBasket
        }
    }
    
    -- DIRECT CALL - ONE LINE FORMAT (executor compatibility!)
    local result = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("DialogueService"):WaitForChild("RF"):WaitForChild("RunCommand"):InvokeServer(unpack(args))
    
    -- Update totals
    AutoSellSystem.totalSold += totalQuantity
    AutoSellSystem.OnSellComplete:Fire(totalQuantity)
    return true, nil, totalQuantity
end

function AutoSellSystem:Start()
    if self.loopRunning then return end
    
    self.loopRunning = true
    self.totalSold = 0
    
    -- Show Live Toast instead of spam
    LiveToast:Update(0)
    
    task.spawn(function()
        while self.loopRunning and not State.isClosing do
            if Config.AutoSellEnabled then
                local items = GetStashItems()
                
                if items and next(items) then
                    local totalItems = 0
                    for _, qty in ipairs(items) do
                        totalItems += qty
                    end
                    
                    if totalItems >= AutoSellConfig.MinItemsToSell then
                        local sellSuccess, sellErr, soldQty = SellItems(items)
                        
                        -- Update Live Toast with new count
                        if sellSuccess and soldQty > 0 then
                            LiveToast:Update(self.totalSold)
                        end
                    end
                end
            end
            
            task.wait(Config.AutoSellInterval)
        end
        
        self.loopRunning = false
    end)
end

function AutoSellSystem:Stop()
    if self.loopRunning then
        ShowToast(string.format("Auto Sell: Stopped (Total: %d)", self.totalSold), "info")
    end
    self.loopRunning = false
    LiveToast:Hide()
end

function AutoSellSystem:IsRunning(): boolean
    return self.loopRunning
end

--// ============================================================
--// GAME ACTIONS
--// ============================================================

local function MinePickaxe()
    pcall(function()
        ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated"):InvokeServer("Pickaxe")
    end)
end

local function AttackWeapon()
    pcall(function()
        ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated"):InvokeServer("Weapon")
    end)
end

local function RunCharacter()
    pcall(function()
        ReplicatedStorage.Shared.Packages.Knit.Services.CharacterService.RF.Run:InvokeServer()
    end)
end

--// ============================================================
--// DEATH RESPAWN SYSTEM (For specific places with spawn issues)
--// ============================================================

local DeathRespawnSystem = {
    isEnabled = false,
    isNavigating = false,
    diedConnection = nil :: RBXScriptConnection?,
    characterAddedConnection = nil :: RBXScriptConnection?,
}

-- The Forge specific place ID
local FORGE_PLACE_ID = 129009554587176

-- Waypoints to navigate after respawn (CFrame components)
local RespawnWaypoints = {
    -- Waypoint 1: Near spawn
    CFrame.new(-336.749329, 90.4807129, -242.832809, -0.0696934313, 0.00767152058, 0.997538984, 0.0895187557, 0.995984137, -0.00140530174, -0.993543744, 0.0892005041, -0.0701003),
    -- Waypoint 2: Mid path
    CFrame.new(-8.7289629, 116.510262, -561.390564, -0.57244575, 0.00688029407, 0.819913745, 0.0879233256, 0.9947142, 0.0530389994, -0.815214932, 0.102451488, -0.570024848),
    -- Waypoint 3: Mining area
    CFrame.new(376.931854, 129.616028, -282.490295, -0.531038046, 0.00760188466, 0.847313881, 0.0800009519, 0.995942831, 0.0412037447, -0.843562961, 0.0896666795, -0.529491663),
}

local function TweenToWaypoint(hrp: BasePart, targetCFrame: CFrame, speed: number?): boolean
    local tweenSpeed = speed or 100
    local distance = (hrp.Position - targetCFrame.Position).Magnitude
    local duration = distance / tweenSpeed
    
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    
    local completed = false
    local connection
    connection = tween.Completed:Connect(function()
        completed = true
        if connection then connection:Disconnect() end
    end)
    
    tween:Play()
    
    -- Wait for completion or timeout
    local startTime = tick()
    local maxWait = duration + 5
    while not completed and (tick() - startTime) < maxWait do
        task.wait(0.1)
    end
    
    return completed
end

local function NavigateAfterRespawn()
    if DeathRespawnSystem.isNavigating then return end
    DeathRespawnSystem.isNavigating = true
    
    ShowToast("Navigating back to mining area...", "info")
    
    -- Wait for character to fully load
    task.wait(2)
    
    local character, hrp, humanoid = MovementController:GetCharacterParts()
    if not character or not hrp then
        ShowToast("Failed to get character!", "error")
        DeathRespawnSystem.isNavigating = false
        return
    end
    
    -- Disable controls during navigation
    if humanoid then
        humanoid.WalkSpeed = 0
        humanoid.JumpPower = 0
    end
    
    -- Navigate through each waypoint
    for i, waypoint in pairs(RespawnWaypoints) do
        ShowToast(string.format("Waypoint %d/%d...", i, #RespawnWaypoints), "info")
        
        -- Refresh character reference
        character, hrp, humanoid = MovementController:GetCharacterParts()
        if not hrp then break end
        
        local success = TweenToWaypoint(hrp, waypoint, 120)
        if not success then
            ShowToast("Navigation interrupted!", "warning")
            break
        end
        
        task.wait(0.5)
    end
    
    -- Restore movement
    character, hrp, humanoid = MovementController:GetCharacterParts()
    if humanoid then
        humanoid.WalkSpeed = StoredHumanoidValues.WalkSpeed or 16
        humanoid.JumpPower = StoredHumanoidValues.JumpPower or 50
    end
    
    ShowToast("Navigation complete! Resuming...", "success")
    DeathRespawnSystem.isNavigating = false
end

function DeathRespawnSystem:Enable()
    if self.isEnabled then return end
    
    -- Only enable for The Forge place
    if game.PlaceId ~= FORGE_PLACE_ID then
        return
    end
    
    self.isEnabled = true
    
    -- Connect to character added
    self.characterAddedConnection = player.CharacterAdded:Connect(function(character)
        -- Only navigate if we were farming
        if State.isAutoMining or State.isAutoKilling then
            task.spawn(function()
                NavigateAfterRespawn()
            end)
        end
    end)
    
    -- Connect to current character's death
    local function connectDeath(character)
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            self.diedConnection = humanoid.Died:Connect(function()
                ShowToast("Died! Will navigate after respawn...", "warning")
            end)
        end
    end
    
    if player.Character then
        connectDeath(player.Character)
    end
    
    player.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        connectDeath(char)
    end)
end

function DeathRespawnSystem:Disable()
    self.isEnabled = false
    
    if self.characterAddedConnection then
        self.characterAddedConnection:Disconnect()
        self.characterAddedConnection = nil
    end
    
    if self.diedConnection then
        self.diedConnection:Disconnect()
        self.diedConnection = nil
    end
end

--// ============================================================
--// FARM SYSTEM
--// ============================================================

local FarmSystem = {
    activeLoop = nil :: thread?,
    isRunning = false,
    currentConfig = nil :: FarmConfig?,
    
    OnFarmStarted = Signal.new(),
    OnFarmStopped = Signal.new(),
    OnTargetFound = Signal.new(),
    OnTargetLost = Signal.new(),
}

function FarmSystem:Start(config: FarmConfig)
    if self.isRunning then
        self:Stop()
    end
    
    self.currentConfig = config
    self.isRunning = true
    State[config.StateKey] = true
    
    self.OnFarmStarted:Fire(config.StateKey)
    
    if Config.AutoSellEnabled then
        AutoSellSystem:Start()
    end
    
    self.activeLoop = task.spawn(function()
        local character, hrp, humanoid = MovementController:GetCharacterParts()
        
        if not character then
            task.wait(1)
            character, hrp, humanoid = MovementController:GetCharacterParts()
        end
        
        if humanoid then
            StoredHumanoidValues.WalkSpeed = humanoid.WalkSpeed
            StoredHumanoidValues.JumpPower = humanoid.JumpPower
            StoredHumanoidValues.JumpHeight = humanoid.JumpHeight
        end
        
        if not CruiseSystem:Initialize() then
            ShowToast("Failed to initialize!", "error")
            self:Stop()
            return
        end
        
        MovementController:InitializePhysics()
        MovementController:EnableNoclip()
        MovementController:StartAntiTpMonitor()
        
        if humanoid then
            humanoid.WalkSpeed = 0
            humanoid.JumpPower = 0
            humanoid.JumpHeight = 0
            humanoid:ChangeState(Enum.HumanoidStateType.Physics)
        end
        
        local cruiseReached = false
        CruiseSystem:RiseToCruise(function(success)
            cruiseReached = true
        end)
        
        while not cruiseReached and State[config.StateKey] and not State.isClosing do
            task.wait(0.1)
        end
        
        if not State[config.StateKey] or State.isClosing then
            self:Cleanup()
            return
        end
        
        while State[config.StateKey] and not State.isClosing do
            character, hrp, humanoid = MovementController:GetCharacterParts()
            
            if not character or not hrp or not humanoid then
                task.wait(1)
                continue
            end
            
            if not MovementController.linearVelocity or not MovementController.linearVelocity.Parent then
                MovementController:InitializePhysics()
            end
            
            if MovementController:IsPaused() then
                MovementController:HoldPosition()
                task.wait(0.1)
                continue
            end
            
            if MovementController:NeedsEscapeRise() then
                MovementController:PerformEscapeRise()
                continue
            end
            
            if Config.AvoidPlayerEnabled then
                local nearestPlayerDist, nearestPlayerPos = GetNearestPlayerDistance()
                
                if nearestPlayerDist < Config.AvoidPlayerDistance and nearestPlayerPos then
                    ShowToast("Avoiding player...", "warning")
                    
                    local myPos = hrp.Position
                    local awayDir = Vector3.new(
                        myPos.X - nearestPlayerPos.X,
                        0,
                        myPos.Z - nearestPlayerPos.Z
                    )
                    
                    if awayDir.Magnitude > 0.1 then
                        awayDir = awayDir.Unit
                    else
                        awayDir = Vector3.new(1, 0, 0)
                    end
                    
                    local escapePos = CruiseSystem:GetCruisePosition(
                        myPos.X + awayDir.X * (Config.AvoidPlayerDistance + 20),
                        myPos.Z + awayDir.Z * (Config.AvoidPlayerDistance + 20)
                    )
                    
                    local escapeDone = false
                    MovementController:MoveTo(escapePos, Config.MoveSpeed, function()
                        escapeDone = true
                    end)
                    
                    while not escapeDone and State[config.StateKey] and not State.isClosing do
                        if GetNearestPlayerDistance() > Config.AvoidPlayerDistance then
                            MovementController:Stop()
                            break
                        end
                        task.wait(0.05)
                    end
                    
                    continue
                end
            end
            
            local target, dist = config.FindTarget()
            
            if not target then
                MovementController:HoldPosition()
                task.wait(1)
                continue
            end
            
            self.OnTargetFound:Fire(target)
            
            local targetPos = config.GetTargetPosition(target)
            if not targetPos then
                task.wait(0.5)
                continue
            end
            
            local actionDistance = config.GetActionDistance()
            local actionPos = Vector3.new(targetPos.X, targetPos.Y - actionDistance, targetPos.Z)
            
            local moveDone = false
            local playerDetected = false
            local targetInvalid = false
            
            MovementController:MoveTo(actionPos, Config.MoveSpeed, function(success)
                moveDone = true
            end)
            
            while not moveDone and State[config.StateKey] and not State.isClosing do
                if not config.IsTargetValid(target) then
                    targetInvalid = true
                    MovementController:Stop()
                    break
                end
                
                if Config.AvoidPlayerEnabled then
                    if GetNearestPlayerDistance() < Config.AvoidPlayerDistance then
                        playerDetected = true
                        MovementController:Stop()
                        break
                    end
                end
                
                MovementController:FaceDirection(Vector3.new(actionPos.X, hrp.Position.Y, actionPos.Z))
                
                task.wait(0.002)
            end
            
            if targetInvalid then
                self.OnTargetLost:Fire(target)
                continue
            end
            
            if playerDetected then
                continue
            end
            
            if not State[config.StateKey] or State.isClosing then
                break
            end
            
            hrp.CFrame = CFrame.new(actionPos)
            task.wait(0.1)
            
            if config.OnTargetReached then
                config.OnTargetReached(target)
            end
            
            local actionStartTime = tick()
            local maxActionTime = 60
            
            -- DAMAGE TRACKING: Record initial health to detect if we can damage this ore
            local initialHealth = GetOreHealth(target)
            local damageCheckTime = tick()
            local hasDamagedTarget = false
            local undamageableTimeout = 3 -- seconds to wait before skipping
            
            while State[config.StateKey] and not State.isClosing do
                if not config.IsTargetValid(target) then
                    break
                end
                
                if tick() - actionStartTime > maxActionTime then
                    break
                end
                
                -- DAMAGE CHECK: After 3 seconds, check if we damaged the ore
                if not hasDamagedTarget and initialHealth and (tick() - damageCheckTime > undamageableTimeout) then
                    local currentHealth = GetOreHealth(target)
                    if currentHealth and currentHealth >= initialHealth then
                        -- Can't damage this ore! Blacklist ENTIRE ROCK TYPE and try lower tier
                        BlacklistRockType(target.Name)
                        break
                    else
                        hasDamagedTarget = true
                    end
                end
                
                if Config.AvoidPlayerEnabled then
                    if GetNearestPlayerDistance() < Config.AvoidPlayerDistance then
                        MovementController:Stop()
                        break
                    end
                end
                
                local newTargetPos = config.GetTargetPosition(target)
                if newTargetPos then
                    local newActionPos = Vector3.new(newTargetPos.X, newTargetPos.Y - actionDistance, newTargetPos.Z)
                    local distToAction = (hrp.Position - newActionPos).Magnitude
                    
                    if distToAction > 3 then
                        local moveSpeed = math.clamp(distToAction * 3, 5, Config.MoveSpeed)
                        local direction = (newActionPos - hrp.Position).Unit
                        
                        if MovementController.linearVelocity and MovementController.linearVelocity.Parent then
                            MovementController.linearVelocity.VectorVelocity = direction * moveSpeed
                        end
                    else
                        MovementController:HoldPosition()
                    end
                    
                    MovementController:FaceTarget(newTargetPos)
                end
                
                config.PerformAction(target)
                
                task.wait(0.002)
            end
            
            if config.OnTargetLost then
                config.OnTargetLost(target)
            end
        end
        
        self:Cleanup()
    end)
end

function FarmSystem:Stop()
    if self.currentConfig then
        State[self.currentConfig.StateKey] = false
    end
    
    self.isRunning = false
    MovementController:Stop()
    AutoSellSystem:Stop()
    
    self.OnFarmStopped:Fire()
end

function FarmSystem:Cleanup()
    MovementController:Cleanup()
    CruiseSystem:Reset()
    
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = StoredHumanoidValues.WalkSpeed
            humanoid.JumpPower = StoredHumanoidValues.JumpPower
            humanoid.JumpHeight = StoredHumanoidValues.JumpHeight
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end
    
    if not State.isClosing then
        ShowToast("Farming stopped", "info")
    end
end

--// ============================================================
--// KILL NEARBY ENEMY SYSTEM (While Mining)
--// ============================================================

local KillNearbySystem = {
    isActive = false,
    isKillingEnemy = false,
    checkLoop = nil :: thread?,
    savedOrePosition = nil :: Vector3?,
}

function KillNearbySystem:KillEnemy(enemy: Instance)
    if self.isKillingEnemy then return end
    self.isKillingEnemy = true
    
    local enemyName = enemy.Name:gsub("%d+$", "")
    ShowToast(string.format("Killing nearby %s...", enemyName), "warning")
    
    -- Save current position to return after
    local _, hrp, _ = MovementController:GetCharacterParts()
    if hrp then
        self.savedOrePosition = hrp.Position
    end
    
    -- Kill the enemy
    local maxKillTime = 10 -- Max 10 seconds to kill
    local killStartTime = tick()
    
    while IsMonsterAlive(enemy) and self.isActive and State.isAutoMining do
        if tick() - killStartTime > maxKillTime then
            ShowToast("Enemy took too long, resuming mining", "info")
            break
        end
        
        local monsterPos = GetMonsterPosition(enemy)
        if not monsterPos then break end
        
        local killDistance = Config.KillDistance
        local actionPos = Vector3.new(monsterPos.X, monsterPos.Y + killDistance, monsterPos.Z)
        
        -- Move to enemy
        MovementController:MoveTo(actionPos, Config.MoveSpeed, function() end)
        
        -- Face and attack
        MovementController:FaceTarget(monsterPos)
        AttackWeapon()
        
        task.wait(0.1)
    end
    
    -- Return to mining position
    if self.savedOrePosition and self.isActive then
        MovementController:MoveTo(self.savedOrePosition, Config.MoveSpeed, function() end)
        task.wait(0.5)
    end
    
    self.isKillingEnemy = false
    self.savedOrePosition = nil
end

function KillNearbySystem:CheckForEnemies()
    if not Config.KillNearbyEnabled then return end
    if not State.isAutoMining then return end
    if self.isKillingEnemy then return end
    
    local enemy, dist = FindNearbyEnemy(Config.KillNearbyRange)
    if enemy and dist then
        task.spawn(function()
            self:KillEnemy(enemy)
        end)
    end
end

function KillNearbySystem:Start()
    if self.isActive then return end
    self.isActive = true
    
    self.checkLoop = task.spawn(function()
        while self.isActive and State.isAutoMining do
            self:CheckForEnemies()
            task.wait(0.5) -- Check every 0.5 seconds
        end
    end)
end

function KillNearbySystem:Stop()
    self.isActive = false
    self.isKillingEnemy = false
    self.savedOrePosition = nil
    
    if self.checkLoop then
        task.cancel(self.checkLoop)
        self.checkLoop = nil
    end
end

--// ============================================================
--// FARM CONFIGURATIONS
--// ============================================================

local MiningConfig: FarmConfig = {
    StateKey = "isAutoMining",
    
    FindTarget = function(): (Instance?, number?)
        return FindNearestOre(true) -- true = prefer highest health
    end,
    
    GetTargetPosition = function(target: Instance): Vector3?
        -- Try GetPivot first, fallback to GetBottomSurface
        local success, pos = pcall(function()
            return target:GetPivot().Position
        end)
        if success and pos then
            return pos
        end
        local bottomPos, _ = GetBottomSurface(target)
        return bottomPos
    end,
    
    IsTargetValid = function(target: Instance): boolean
        -- Check if target exists
        if not target or not target.Parent then return false end
        
        -- Check if ore is alive
        local health = target:GetAttribute("Health")
        if health ~= nil and health <= 0 then return false end
        
        -- CHECK: Is someone else mining this now?
        if not CanMineRock(target) then return false end
        
        return true
    end,
    
    PerformAction = function(target: Instance)
        MinePickaxe()
    end,
    
    GetActionDistance = function(): number
        return Config.MineDistance
    end,
    
    OnTargetLost = function(target: Instance)
        SetOreCooldown(target)
    end,
}

local KillingConfig: FarmConfig = {
    StateKey = "isAutoKilling",
    
    FindTarget = function(): (Instance?, number?)
        return FindNearestMonster()
    end,
    
    GetTargetPosition = function(target: Instance): Vector3?
        return GetMonsterPosition(target)
    end,
    
    IsTargetValid = function(target: Instance): boolean
        return IsMonsterAlive(target)
    end,
    
    PerformAction = function(target: Instance)
        AttackWeapon()
    end,
    
    GetActionDistance = function(): number
        return Config.KillDistance
    end,
}

--// ============================================================
--// CONVENIENCE FUNCTIONS
--// ============================================================

local function StartAutoMine()
    if State.isAutoMining then return end
    
    -- Require target selection
    if #Config.SelectedSources == 0 then
        ShowToast("Open Ore Manager and select ores first!", "warning")
        return
    end
    
    -- CLEAR rock type blacklist on fresh start
    ClearRockTypeBlacklist()
    
    -- Enable death respawn system for The Forge
    DeathRespawnSystem:Enable()
    
    -- Show what rocks we're targeting
    local targetList = table.concat(Config.SelectedSources, ", ")
    ShowToast(string.format("Mining: %s", targetList), "success")
    
    FarmSystem:Start(MiningConfig)
    
    -- Start Kill Nearby Enemy system if enabled
    if Config.KillNearbyEnabled then
        KillNearbySystem:Start()
    end
end

local function StopAutoMine()
    if not State.isAutoMining then return end
    
    -- Stop Kill Nearby Enemy system
    KillNearbySystem:Stop()
    
    -- CLEAR rock type blacklist when stopped
    ClearRockTypeBlacklist()
    
    DeathRespawnSystem:Disable()
    FarmSystem:Stop()
end

local function StartAutoKill()
    if State.isAutoKilling then return end
    
    if #Config.SelectedMonsters == 0 then
        ShowToast("Select monsters first!", "warning")
        return
    end
    
    -- Enable death respawn system for The Forge
    DeathRespawnSystem:Enable()
    
    ShowToast("Killing Started!", "success")
    FarmSystem:Start(KillingConfig)
end

local function StopAutoKill()
    if not State.isAutoKilling then return end
    DeathRespawnSystem:Disable()
    FarmSystem:Stop()
end

--// ============================================================
--// ESP SYSTEM
--// ============================================================

local EspSystem = {
    trackedPlayers = {} :: {[Player]: {Highlight: Highlight, Billboard: BillboardGui}},
    trackedMonsters = {} :: {[Instance]: {Highlight: Highlight, Billboard: BillboardGui}},
    trackedOres = {} :: {[Instance]: {Highlight: Highlight, Billboard: BillboardGui}},
    updateConnection = nil :: Connection?,
}

local function CreateEspObjects(target: Instance, color: Color3, name: string): (Highlight, BillboardGui)
    local existingHighlight = target:FindFirstChild("ESP_Highlight")
    if existingHighlight then existingHighlight:Destroy() end
    
    local existingBillboard = target:FindFirstChild("ESP_Billboard")
    if existingBillboard then existingBillboard:Destroy() end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.FillColor = color
    highlight.OutlineColor = color
    highlight.FillTransparency = 0.7
    highlight.OutlineTransparency = 0
    highlight.Adornee = target
    highlight.Parent = target
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_Billboard"
    billboard.Size = UDim2.new(0, 100, 0, 30)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Adornee = target
    billboard.Parent = target
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(1, 0, 1, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = name
    nameLabel.TextColor3 = color
    nameLabel.TextStrokeTransparency = 0.5
    nameLabel.TextSize = 12
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.Parent = billboard
    
    return highlight, billboard
end

local function UpdateEspLabel(billboard: BillboardGui, text: string)
    local label = billboard:FindFirstChild("NameLabel")
    if label and label:IsA("TextLabel") then
        label.Text = text
    end
end

local function DestroyEspObjects(espData: {Highlight: Highlight, Billboard: BillboardGui})
    if espData.Highlight and espData.Highlight.Parent then
        espData.Highlight:Destroy()
    end
    if espData.Billboard and espData.Billboard.Parent then
        espData.Billboard:Destroy()
    end
end

function EspSystem:UpdatePlayers()
    if not Config.EspPlayersEnabled then
        for plr, espData in pairs(self.trackedPlayers) do
            DestroyEspObjects(espData)
        end
        table.clear(self.trackedPlayers)
        return
    end
    
    local _, myHrp, _ = MovementController:GetCharacterParts()
    if not myHrp then return end
    
    local currentPlayers: {[Player]: boolean} = {}
    
    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherHrp = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHrp and otherHrp:IsA("BasePart") then
                local dist = (myHrp.Position - otherHrp.Position).Magnitude
                
                if dist <= Config.EspDistance then
                    currentPlayers[otherPlayer] = true
                    
                    local displayText = `{otherPlayer.Name} [{math.floor(dist)}m]`
                    
                    if self.trackedPlayers[otherPlayer] then
                        UpdateEspLabel(self.trackedPlayers[otherPlayer].Billboard, displayText)
                    else
                        local highlight, billboard = CreateEspObjects(
                            otherPlayer.Character,
                            Color3.fromRGB(255, 100, 100),
                            displayText
                        )
                        self.trackedPlayers[otherPlayer] = {Highlight = highlight, Billboard = billboard}
                    end
                end
            end
        end
    end
    
    for plr, espData in pairs(self.trackedPlayers) do
        if not currentPlayers[plr] then
            DestroyEspObjects(espData)
            self.trackedPlayers[plr] = nil
        end
    end
end

function EspSystem:UpdateMonsters()
    if not Config.EspMonstersEnabled then
        for monster, espData in pairs(self.trackedMonsters) do
            DestroyEspObjects(espData)
        end
        table.clear(self.trackedMonsters)
        return
    end
    
    local _, myHrp, _ = MovementController:GetCharacterParts()
    if not myHrp then return end
    
    local livingFolder = Workspace:FindFirstChild("Living")
    if not livingFolder then return end
    
    local currentMonsters: {[Instance]: boolean} = {}
    
    for _, entity in ipairs(livingFolder:GetChildren()) do
        if entity:IsA("Model") then
            local isNpc = entity:GetAttribute("IsNpc")
            if isNpc == true then
                local hum = entity:FindFirstChildOfClass("Humanoid")
                if hum and hum.Health > 0 then
                    local monsterHrp = entity:FindFirstChild("HumanoidRootPart") or (entity :: Model).PrimaryPart
                    if monsterHrp and monsterHrp:IsA("BasePart") then
                        local dist = (myHrp.Position - monsterHrp.Position).Magnitude
                        
                        if dist <= Config.EspDistance then
                            currentMonsters[entity] = true
                            
                            local displayText = `{entity.Name} [{math.floor(dist)}m]`
                            
                            if self.trackedMonsters[entity] then
                                UpdateEspLabel(self.trackedMonsters[entity].Billboard, displayText)
                            else
                                local highlight, billboard = CreateEspObjects(
                                    entity,
                                    Color3.fromRGB(255, 50, 50),
                                    displayText
                                )
                                self.trackedMonsters[entity] = {Highlight = highlight, Billboard = billboard}
                            end
                        end
                    end
                end
            end
        end
    end
    
    for monster, espData in pairs(self.trackedMonsters) do
        if not currentMonsters[monster] then
            DestroyEspObjects(espData)
            self.trackedMonsters[monster] = nil
        end
    end
end

function EspSystem:UpdateOres()
    if not Config.EspOresEnabled then
        for ore, espData in pairs(self.trackedOres) do
            DestroyEspObjects(espData)
        end
        table.clear(self.trackedOres)
        return
    end
    
    local _, myHrp, _ = MovementController:GetCharacterParts()
    if not myHrp then return end
    
    local rocksFolder = Workspace:FindFirstChild("Rocks")
    if not rocksFolder then return end
    
    local currentOres: {[Instance]: boolean} = {}
    
    for _, mapFolder in ipairs(rocksFolder:GetChildren()) do
        if mapFolder:IsA("Model") or mapFolder:IsA("Folder") then
            for _, spawnLocation in ipairs(mapFolder:GetChildren()) do
                for _, ore in ipairs(spawnLocation:GetChildren()) do
                    if (ore:IsA("Model") or ore:IsA("BasePart")) and IsOreAlive(ore) then
                        local orePart = (ore :: Model).PrimaryPart or ore:FindFirstChildWhichIsA("BasePart")
                        if not orePart and ore:IsA("BasePart") then
                            orePart = ore :: BasePart
                        end
                        
                        if orePart then
                            local dist = (myHrp.Position - orePart.Position).Magnitude
                            
                            if dist <= Config.EspDistance then
                                currentOres[ore] = true
                                
                                local displayText = `{ore.Name} [{math.floor(dist)}m]`
                                
                                if self.trackedOres[ore] then
                                    UpdateEspLabel(self.trackedOres[ore].Billboard, displayText)
                                else
                                    local highlight, billboard = CreateEspObjects(
                                        ore,
                                        Color3.fromRGB(100, 200, 255),
                                        displayText
                                    )
                                    self.trackedOres[ore] = {Highlight = highlight, Billboard = billboard}
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    for ore, espData in pairs(self.trackedOres) do
        if not currentOres[ore] then
            DestroyEspObjects(espData)
            self.trackedOres[ore] = nil
        end
    end
end

function EspSystem:Start()
    if self.updateConnection then return end
    
    self.updateConnection = TrackConnection(RunService.Heartbeat:Connect(function()
        if State.isClosing then
            self:Stop()
            return
        end
        
        task.wait(0.5)
        
        self:UpdatePlayers()
        self:UpdateMonsters()
        self:UpdateOres()
    end))
end

function EspSystem:Stop()
    if self.updateConnection then
        self.updateConnection:Disconnect()
        self.updateConnection = nil
    end
    
    for _, espData in ipairs(self.trackedPlayers) do
        DestroyEspObjects(espData)
    end
    for _, espData in ipairs(self.trackedMonsters) do
        DestroyEspObjects(espData)
    end
    for _, espData in ipairs(self.trackedOres) do
        DestroyEspObjects(espData)
    end
    
    table.clear(self.trackedPlayers)
    table.clear(self.trackedMonsters)
    table.clear(self.trackedOres)
end

EspSystem:Start()

--// ============================================================
--// MISC FEATURES
--// ============================================================

local function SetWalkSpeed(speed: number)
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = speed
        end
    end
end

local function EnableFullbright()
    OriginalLighting.Brightness = Lighting.Brightness
    OriginalLighting.Ambient = Lighting.Ambient
    OriginalLighting.OutdoorAmbient = Lighting.OutdoorAmbient
    OriginalLighting.FogEnd = Lighting.FogEnd
    OriginalLighting.FogStart = Lighting.FogStart
    
    Lighting.Brightness = 2
    Lighting.Ambient = Color3.fromRGB(178, 178, 178)
    Lighting.OutdoorAmbient = Color3.fromRGB(178, 178, 178)
    Lighting.FogEnd = 100000
    Lighting.FogStart = 100000
    
    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("ColorCorrectionEffect") 
            or v:IsA("SunRaysEffect") or v:IsA("DepthOfFieldEffect") then
            pcall(function() v.Enabled = false end)
        elseif v:IsA("Atmosphere") then
            pcall(function()
                v.Density = 0
                v.Offset = 0
                v.Glare = 0
                v.Haze = 0
            end)
        end
    end
end

local function DisableFullbright()
    if OriginalLighting.Brightness then
        Lighting.Brightness = OriginalLighting.Brightness
        Lighting.Ambient = OriginalLighting.Ambient
        Lighting.OutdoorAmbient = OriginalLighting.OutdoorAmbient
        Lighting.FogEnd = OriginalLighting.FogEnd or 10000
        Lighting.FogStart = OriginalLighting.FogStart or 0
    end
    
    for _, v in ipairs(Lighting:GetChildren()) do
        if v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("ColorCorrectionEffect")
            or v:IsA("SunRaysEffect") or v:IsA("DepthOfFieldEffect") then
            pcall(function() v.Enabled = true end)
        end
    end
end

-- Misc loops
task.spawn(function()
    while ScreenGui and ScreenGui.Parent and not State.isClosing do
        if Config.AutoRunEnabled then
            RunCharacter()
        end
        task.wait(0.2)
    end
end)

task.spawn(function()
    while ScreenGui and ScreenGui.Parent and not State.isClosing do
        if Config.WalkSpeedEnabled and not State.isAutoMining and not State.isAutoKilling then
            SetWalkSpeed(Config.CustomWalkSpeed)
        end
        task.wait(0.5)
    end
end)

--// ============================================================
--// UI BUILDING - MAIN FRAME FIRST (FIX FOR NIL ERROR)
--// ============================================================

-- Main Window (CREATE THIS FIRST!)
local MainFrame = CreateInstance("Frame", {
    Name = "MainFrame",
    Size = MainFrameSize,
    Position = UDim2.new(0.5, -MainFrameSize.X.Offset/2, 0.5, -MainFrameSize.Y.Offset/2),
    BackgroundColor3 = Theme.Background,
    BackgroundTransparency = Theme.PanelTransparency,
    BorderSizePixel = 0,
    ClipsDescendants = true,
    Parent = ScreenGui
}) :: Frame
AddCorner(MainFrame, 12)
AddStroke(MainFrame, Theme.Border, 1)

-- Shadow
local Shadow = CreateInstance("ImageLabel", {
    Name = "Shadow",
    Size = UDim2.new(1, 50, 1, 50),
    Position = UDim2.new(0, -25, 0, -25),
    BackgroundTransparency = 1,
    Image = "rbxassetid://5028857084",
    ImageColor3 = Color3.fromRGB(0, 0, 0),
    ImageTransparency = 0.5,
    ScaleType = Enum.ScaleType.Slice,
    SliceCenter = Rect.new(24, 24, 276, 276),
    ZIndex = -1,
    Parent = MainFrame
}) :: ImageLabel

--// ============================================================
--// TOGGLE BUTTON (CREATED AFTER MainFrame!)
--// ============================================================

local ToggleButton = CreateInstance("ImageButton", {
    Name = "ToggleButton",
    Size = ToggleButtonSize,
    Position = UDim2.new(0, 10, 0.5, -25),
    BackgroundColor3 = Theme.Accent,
    BackgroundTransparency = 0.2,
    Image = Icons.Toggle,
    ImageColor3 = Theme.TextPrimary,
    ScaleType = Enum.ScaleType.Fit,
    BorderSizePixel = 0,
    ZIndex = 100,
    Parent = ScreenGui
}) :: ImageButton
AddCorner(ToggleButton, 12)
AddStroke(ToggleButton, Theme.AccentLight, 2)

-- Toggle button glow
local ToggleGlow = CreateInstance("ImageLabel", {
    Name = "Glow",
    Size = UDim2.new(1, 20, 1, 20),
    Position = UDim2.new(0, -10, 0, -10),
    BackgroundTransparency = 1,
    Image = "rbxassetid://5028857084",
    ImageColor3 = Theme.Accent,
    ImageTransparency = 0.7,
    ScaleType = Enum.ScaleType.Slice,
    SliceCenter = Rect.new(24, 24, 276, 276),
    ZIndex = 99,
    Parent = ToggleButton
}) :: ImageLabel

-- Toggle button dragging
local toggleDragging = false
local toggleDragStart: Vector3? = nil
local toggleStartPos: UDim2? = nil
local toggleDragDelta = 0

ToggleButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        toggleDragging = true
        toggleDragStart = input.Position
        toggleStartPos = ToggleButton.Position
        toggleDragDelta = 0
    end
end)

ToggleButton.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        if toggleDragging then
            -- If barely moved, treat as click (toggle UI visibility)
            if toggleDragDelta < 10 then
                State.isMainUIVisible = not State.isMainUIVisible
                
                if State.isMainUIVisible then
                    MainFrame.Visible = true
                    Tween(MainFrame, {Position = UDim2.new(0.5, -MainFrameSize.X.Offset/2, 0.5, -MainFrameSize.Y.Offset/2)}, 0.3, Enum.EasingStyle.Back)
                    Tween(ToggleButton, {ImageColor3 = Theme.TextPrimary, Rotation = 0}, 0.3)
                    Tween(ToggleGlow, {ImageColor3 = Theme.Accent}, 0.3)
                else
                    Tween(MainFrame, {Position = UDim2.new(0.5, -MainFrameSize.X.Offset/2, 1.5, 0)}, 0.3, Enum.EasingStyle.Quint)
                    Tween(ToggleButton, {ImageColor3 = Theme.Warning, Rotation = 180}, 0.3)
                    Tween(ToggleGlow, {ImageColor3 = Theme.Warning}, 0.3)
                    task.delay(0.3, function()
                        if not State.isMainUIVisible and MainFrame then
                            MainFrame.Visible = false
                        end
                    end)
                end
            end
        end
        toggleDragging = false
        toggleDragDelta = 0
    end
end)

TrackConnection(UserInputService.InputChanged:Connect(function(input)
    if toggleDragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
        if toggleDragStart and toggleStartPos then
            local delta = input.Position - toggleDragStart
            toggleDragDelta = delta.Magnitude
            
            local newX = math.clamp(toggleStartPos.X.Offset + delta.X, 0, ScreenSize.X - ToggleButton.AbsoluteSize.X)
            local newY = math.clamp(toggleStartPos.Y.Offset + delta.Y, 0, ScreenSize.Y - ToggleButton.AbsoluteSize.Y)
            
            ToggleButton.Position = UDim2.new(
                toggleStartPos.X.Scale,
                newX,
                toggleStartPos.Y.Scale,
                newY
            )
        end
    end
end))

--// ============================================================
--// TITLE BAR
--// ============================================================

local TitleBar = CreateInstance("Frame", {
    Name = "TitleBar",
    Size = UDim2.new(1, 0, 0, IsMobile and 40 or 45),
    BackgroundColor3 = Theme.BackgroundSecondary,
    BackgroundTransparency = Theme.PanelTransparency,
    BorderSizePixel = 0,
    Parent = MainFrame
}) :: Frame
AddCorner(TitleBar, 12)

CreateInstance("Frame", {
    Size = UDim2.new(1, 0, 0, 15),
    Position = UDim2.new(0, 0, 1, -15),
    BackgroundColor3 = Theme.BackgroundSecondary,
    BackgroundTransparency = Theme.PanelTransparency,
    BorderSizePixel = 0,
    Parent = TitleBar
})

CreateInstance("ImageLabel", {
    Size = UDim2.new(0, IsMobile and 20 or 24, 0, IsMobile and 20 or 24),
    Position = UDim2.new(0, 10, 0.5, IsMobile and -10 or -12),
    BackgroundTransparency = 1,
    Image = Icons.Toggle,
    ImageColor3 = Theme.Accent,
    Parent = TitleBar
})

CreateInstance("TextLabel", {
    Size = UDim2.new(0, 180, 1, 0),
    Position = UDim2.new(0, IsMobile and 35 or 42, 0, 0),
    BackgroundTransparency = 1,
    Text = "Glad Hub | The Forge",
    TextColor3 = Theme.TextPrimary,
    TextSize = IsMobile and 14 or 18,
    Font = Enum.Font.GothamBlack,
    TextXAlignment = Enum.TextXAlignment.Left,
    Parent = TitleBar
})

local VersionBadge = CreateInstance("TextLabel", {
    Size = UDim2.new(0, 40, 0, 16),
    Position = UDim2.new(0, IsMobile and 175 or 200, 0.5, -8),
    BackgroundColor3 = Theme.Accent,
    BackgroundTransparency = Theme.ButtonTransparency,
    Text = "V7.3",
    TextColor3 = Theme.TextPrimary,
    TextSize = 10,
    Font = Enum.Font.GothamBold,
    Parent = TitleBar
}) :: TextLabel
AddCorner(VersionBadge, 4)

-- Close Button
local CloseButton = CreateInstance("TextButton", {
    Size = UDim2.new(0, IsMobile and 28 or 30, 0, IsMobile and 28 or 30),
    Position = UDim2.new(1, IsMobile and -36 or -42, 0.5, IsMobile and -14 or -15),
    BackgroundColor3 = Theme.Error,
    BackgroundTransparency = Theme.ButtonTransparency,
    Text = "X",
    TextColor3 = Theme.TextPrimary,
    TextSize = IsMobile and 12 or 14,
    Font = Enum.Font.GothamBold,
    BorderSizePixel = 0,
    Parent = TitleBar
}) :: TextButton
AddCorner(CloseButton, 6)

-- Minimize Button
local MinimizeButton = CreateInstance("TextButton", {
    Size = UDim2.new(0, IsMobile and 28 or 30, 0, IsMobile and 28 or 30),
    Position = UDim2.new(1, IsMobile and -68 or -78, 0.5, IsMobile and -14 or -15),
    BackgroundColor3 = Theme.Warning,
    BackgroundTransparency = Theme.ButtonTransparency,
    Text = "-",
    TextColor3 = Theme.TextPrimary,
    TextSize = IsMobile and 16 or 18,
    Font = Enum.Font.GothamBold,
    BorderSizePixel = 0,
    Parent = TitleBar
}) :: TextButton
AddCorner(MinimizeButton, 6)

-- Sidebar
local Sidebar = CreateInstance("Frame", {
    Name = "Sidebar",
    Size = UDim2.new(0, SidebarWidth, 1, IsMobile and -45 or -55),
    Position = UDim2.new(0, 5, 0, IsMobile and 42 or 50),
    BackgroundColor3 = Theme.BackgroundSecondary,
    BackgroundTransparency = Theme.PanelTransparency,
    BorderSizePixel = 0,
    Parent = MainFrame
}) :: Frame
AddCorner(Sidebar, 10)

CreateInstance("UIListLayout", {
    SortOrder = Enum.SortOrder.LayoutOrder,
    Padding = UDim.new(0, 4),
    HorizontalAlignment = Enum.HorizontalAlignment.Center,
    Parent = Sidebar
})

CreateInstance("UIPadding", {
    PaddingTop = UDim.new(0, 6),
    Parent = Sidebar
})

-- Content Area
local ContentArea = CreateInstance("Frame", {
    Name = "ContentArea",
    Size = UDim2.new(1, -(SidebarWidth + 15), 1, IsMobile and -45 or -55),
    Position = UDim2.new(0, SidebarWidth + 10, 0, IsMobile and 42 or 50),
    BackgroundColor3 = Theme.BackgroundSecondary,
    BackgroundTransparency = Theme.PanelTransparency,
    BorderSizePixel = 0,
    ClipsDescendants = true,
    Parent = MainFrame
}) :: Frame
AddCorner(ContentArea, 10)

--// ============================================================
--// CATEGORY SYSTEM
--// ============================================================

local CategoryButtons: {[string]: {Button: TextButton, Icon: ImageLabel, Label: TextLabel, Indicator: Frame}} = {}
local CategoryPages: {[string]: ScrollingFrame} = {}

local CategoryData = {
    {name = "Auto", icon = Icons.Auto, order = 1},
    {name = "ESP", icon = Icons.ESP, order = 2},
    {name = "Misc", icon = Icons.Misc, order = 3},
    {name = "Settings", icon = Icons.Settings, order = 4},
}

local function CreateCategoryButton(data: {name: string, icon: string, order: number}): TextButton
    local buttonSize = IsMobile and 45 or 55
    
    local button = CreateInstance("TextButton", {
        Name = data.name .. "Button",
        Size = UDim2.new(0, buttonSize, 0, buttonSize),
        BackgroundColor3 = Theme.CategoryInactive,
        BackgroundTransparency = Theme.ButtonTransparency,
        Text = "",
        BorderSizePixel = 0,
        LayoutOrder = data.order,
        Parent = Sidebar
    }) :: TextButton
    AddCorner(button, 10)
    
    local icon = CreateInstance("ImageLabel", {
        Size = UDim2.new(0, IsMobile and 18 or 22, 0, IsMobile and 18 or 22),
        Position = UDim2.new(0.5, IsMobile and -9 or -11, 0, IsMobile and 6 or 8),
        BackgroundTransparency = 1,
        Image = data.icon,
        ImageColor3 = Theme.TextSecondary,
        Parent = button
    }) :: ImageLabel
    
    local label = CreateInstance("TextLabel", {
        Size = UDim2.new(1, 0, 0, 12),
        Position = UDim2.new(0, 0, 1, IsMobile and -14 or -18),
        BackgroundTransparency = 1,
        Text = data.name,
        TextColor3 = Theme.TextSecondary,
        TextSize = IsMobile and 8 or 9,
        Font = Enum.Font.GothamMedium,
        Parent = button
    }) :: TextLabel
    
    local indicator = CreateInstance("Frame", {
        Name = "Indicator",
        Size = UDim2.new(0, 3, 0.6, 0),
        Position = UDim2.new(0, 0, 0.2, 0),
        BackgroundColor3 = Theme.Accent,
        BackgroundTransparency = 1,
        BorderSizePixel = 0,
        Parent = button
    }) :: Frame
    AddCorner(indicator, 2)
    
    CategoryButtons[data.name] = {
        Button = button,
        Icon = icon,
        Label = label,
        Indicator = indicator
    }
    
    return button
end

local function CreateCategoryPage(name: string): ScrollingFrame
    local page = CreateInstance("ScrollingFrame", {
        Name = name .. "Page",
        Size = UDim2.new(1, -16, 1, -16),
        Position = UDim2.new(0, 8, 0, 8),
        BackgroundTransparency = 1,
        ScrollBarThickness = 4,
        ScrollBarImageColor3 = Theme.Accent,
        CanvasSize = UDim2.new(0, 0, 0, 0),
        AutomaticCanvasSize = Enum.AutomaticSize.Y,
        Visible = name == "Auto",
        ClipsDescendants = true,
        Parent = ContentArea
    }) :: ScrollingFrame
    
    CreateInstance("UIListLayout", {
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 6),
        Parent = page
    })
    
    CategoryPages[name] = page
    return page
end

local function SwitchCategory(categoryName: string)
    State.currentCategory = categoryName
    
    for name, components in pairs(CategoryButtons) do
        local isActive = name == categoryName
        
        Tween(components.Button, {BackgroundColor3 = isActive and Theme.CategoryActive or Theme.CategoryInactive}, 0.2)
        Tween(components.Indicator, {BackgroundTransparency = isActive and 0 or 1}, 0.2)
        Tween(components.Label, {TextColor3 = isActive and Theme.TextPrimary or Theme.TextSecondary}, 0.2)
        Tween(components.Icon, {ImageColor3 = isActive and Theme.TextPrimary or Theme.TextSecondary}, 0.2)
    end
    
    for name, page in pairs(CategoryPages) do
        if name == categoryName then
            page.Visible = true
            page.Position = UDim2.new(0.1, 8, 0, 8)
            Tween(page, {Position = UDim2.new(0, 8, 0, 8)}, 0.3, Enum.EasingStyle.Back)
        else
            page.Visible = false
        end
    end
end

for _, data in ipairs(CategoryData) do
    local button = CreateCategoryButton(data)
    CreateCategoryPage(data.name)
    
    button.MouseButton1Click:Connect(function()
        SwitchCategory(data.name)
    end)
    
    button.MouseEnter:Connect(function()
        if State.currentCategory ~= data.name then
            Tween(button, {BackgroundColor3 = Theme.BackgroundTertiary}, 0.15)
        end
    end)
    
    button.MouseLeave:Connect(function()
        if State.currentCategory ~= data.name then
            Tween(button, {BackgroundColor3 = Theme.CategoryInactive}, 0.15)
        end
    end)
end

SwitchCategory("Auto")

--// ============================================================
--// UI COMPONENT CREATORS
--// ============================================================

local function CreateSection(parent: Instance, title: string, order: number?): Frame
    local section = CreateInstance("Frame", {
        Name = title .. "Section",
        Size = UDim2.new(1, 0, 0, IsMobile and 24 or 30),
        BackgroundTransparency = 1,
        LayoutOrder = order or 0,
        Parent = parent
    }) :: Frame
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundTransparency = 1,
        Text = "  " .. title,
        TextColor3 = Theme.TextSecondary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.GothamBold,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = section
    })
    
    CreateInstance("Frame", {
        Size = UDim2.new(1, -10, 0, 1),
        Position = UDim2.new(0, 5, 1, -4),
        BackgroundColor3 = Theme.Border,
        BorderSizePixel = 0,
        Parent = section
    })
    
    return section
end

local function CreateToggle(parent: Instance, text: string, iconAsset: string?, order: number?, callback: ((boolean) -> ())?): {Container: Frame, SetState: (boolean) -> (), GetState: () -> boolean}
    local container = CreateInstance("Frame", {
        Name = text .. "Toggle",
        Size = UDim2.new(1, 0, 0, IsMobile and 38 or 45),
        BackgroundColor3 = Theme.BackgroundTertiary,
        BackgroundTransparency = Theme.ButtonTransparency,
        BorderSizePixel = 0,
        LayoutOrder = order or 0,
        Parent = parent
    }) :: Frame
    AddCorner(container, 8)
    
    local iconLabel = CreateInstance("ImageLabel", {
        Size = UDim2.new(0, IsMobile and 16 or 20, 0, IsMobile and 16 or 20),
        Position = UDim2.new(0, 10, 0.5, IsMobile and -8 or -10),
        BackgroundTransparency = 1,
        Image = iconAsset or "",
        ImageColor3 = Theme.TextSecondary,
        Parent = container
    }) :: ImageLabel
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, -90, 1, 0),
        Position = UDim2.new(0, IsMobile and 32 or 40, 0, 0),
        BackgroundTransparency = 1,
        Text = text,
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 11 or 13,
        Font = Enum.Font.GothamMedium,
        TextXAlignment = Enum.TextXAlignment.Left,
        TextTruncate = Enum.TextTruncate.AtEnd,
        Parent = container
    })
    
    local switchBg = CreateInstance("Frame", {
        Size = UDim2.new(0, IsMobile and 38 or 44, 0, IsMobile and 20 or 24),
        Position = UDim2.new(1, IsMobile and -48 or -55, 0.5, IsMobile and -10 or -12),
        BackgroundColor3 = Theme.Border,
        BorderSizePixel = 0,
        Parent = container
    }) :: Frame
    AddCorner(switchBg, 12)
    
    local switchKnob = CreateInstance("Frame", {
        Size = UDim2.new(0, IsMobile and 16 or 20, 0, IsMobile and 16 or 20),
        Position = UDim2.new(0, 2, 0.5, IsMobile and -8 or -10),
        BackgroundColor3 = Theme.TextPrimary,
        BorderSizePixel = 0,
        Parent = switchBg
    }) :: Frame
    AddCorner(switchKnob, 10)
    
    local isEnabled = false
    
    local function SetState(state: boolean)
        isEnabled = state
        Tween(switchBg, {BackgroundColor3 = state and Theme.Accent or Theme.Border}, 0.2)
        Tween(switchKnob, {Position = state and UDim2.new(1, IsMobile and -18 or -22, 0.5, IsMobile and -8 or -10) or UDim2.new(0, 2, 0.5, IsMobile and -8 or -10)}, 0.2, Enum.EasingStyle.Back)
        Tween(iconLabel, {ImageColor3 = state and Theme.Accent or Theme.TextSecondary}, 0.2)
    end
    
    container.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isEnabled = not isEnabled
            SetState(isEnabled)
            if callback then
                callback(isEnabled)
            end
        end
    end)
    
    container.MouseEnter:Connect(function()
        Tween(container, {BackgroundColor3 = Theme.BorderLight}, 0.15)
    end)
    
    container.MouseLeave:Connect(function()
        Tween(container, {BackgroundColor3 = Theme.BackgroundTertiary}, 0.15)
    end)
    
    return {
        Container = container,
        SetState = SetState,
        GetState = function() return isEnabled end
    }
end

local function CreateDropdown(parent: Instance, text: string, options: {string}?, order: number?, multiSelect: boolean?, callback: (({string}) -> ())?): {Container: Frame, UpdateOptions: ({string}) -> (), GetSelected: () -> {string}}
    local container = CreateInstance("Frame", {
        Name = text .. "Dropdown",
        Size = UDim2.new(1, 0, 0, IsMobile and 38 or 45),
        BackgroundColor3 = Theme.BackgroundTertiary,
        BackgroundTransparency = Theme.ButtonTransparency,
        BorderSizePixel = 0,
        ClipsDescendants = false,
        LayoutOrder = order or 0,
        ZIndex = 5,
        Parent = parent
    }) :: Frame
    AddCorner(container, 8)
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(1, -40, 0, IsMobile and 38 or 45),
        Position = UDim2.new(0, 10, 0, 0),
        BackgroundTransparency = 1,
        Text = text,
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 11 or 13,
        Font = Enum.Font.GothamMedium,
        TextXAlignment = Enum.TextXAlignment.Left,
        TextTruncate = Enum.TextTruncate.AtEnd,
        ZIndex = 6,
        Parent = container
    })
    
    local arrowLabel = CreateInstance("TextLabel", {
        Size = UDim2.new(0, 25, 0, IsMobile and 38 or 45),
        Position = UDim2.new(1, -30, 0, 0),
        BackgroundTransparency = 1,
        Text = "v",
        TextColor3 = Theme.TextSecondary,
        TextSize = IsMobile and 10 or 12,
        Font = Enum.Font.GothamBold,
        ZIndex = 6,
        Parent = container
    }) :: TextLabel
    
    local dropdownList = CreateInstance("ScrollingFrame", {
        Name = "DropdownList_" .. text,
        Size = UDim2.new(0, 0, 0, 0),
        Position = UDim2.new(0, 0, 0, 0),
        BackgroundColor3 = Theme.BackgroundSecondary,
        BackgroundTransparency = 0,
        BorderSizePixel = 0,
        ClipsDescendants = true,
        Visible = false,
        ZIndex = 9999,
        ScrollBarThickness = 4,
        ScrollBarImageColor3 = Theme.Accent,
        CanvasSize = UDim2.new(0, 0, 0, 0),
        AutomaticCanvasSize = Enum.AutomaticSize.Y,
        ScrollingDirection = Enum.ScrollingDirection.Y,
        Parent = MainFrame
    }) :: ScrollingFrame
    AddCorner(dropdownList, 8)
    AddStroke(dropdownList, Theme.Accent, 2)
    
    CreateInstance("UIListLayout", {
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 2),
        Parent = dropdownList
    })
    
    CreateInstance("UIPadding", {
        PaddingTop = UDim.new(0, 4),
        PaddingBottom = UDim.new(0, 4),
        PaddingLeft = UDim.new(0, 4),
        PaddingRight = UDim.new(0, 8),
        Parent = dropdownList
    })
    
    local isOpen = false
    local selectedItems: {[string]: boolean} = {}
    local optionButtons: {TextButton} = {}
    local positionTracker: Connection? = nil
    
    local function UpdateOptions(newOptions: {string})
        for _, btn in ipairs(optionButtons) do
            btn:Destroy()
        end
        table.clear(optionButtons)
        table.clear(selectedItems)
        
        for i, option in pairs(newOptions) do
            local optBtn = CreateInstance("TextButton", {
                Name = option,
                Size = UDim2.new(1, 0, 0, IsMobile and 28 or 32),
                BackgroundColor3 = Theme.BackgroundTertiary,
                BackgroundTransparency = 0,
                Text = "",
                BorderSizePixel = 0,
                LayoutOrder = i,
                ZIndex = 10000,
                Parent = dropdownList
            }) :: TextButton
            AddCorner(optBtn, 6)
            
            local checkmark = CreateInstance("TextLabel", {
                Size = UDim2.new(0, 20, 1, 0),
                BackgroundTransparency = 1,
                Text = "",
                TextColor3 = Theme.Accent,
                TextSize = IsMobile and 12 or 14,
                Font = Enum.Font.GothamBold,
                ZIndex = 10001,
                Parent = optBtn
            }) :: TextLabel
            
            CreateInstance("TextLabel", {
                Size = UDim2.new(1, -25, 1, 0),
                Position = UDim2.new(0, 22, 0, 0),
                BackgroundTransparency = 1,
                Text = option,
                TextColor3 = Theme.TextPrimary,
                TextSize = IsMobile and 10 or 12,
                Font = Enum.Font.Gotham,
                TextXAlignment = Enum.TextXAlignment.Left,
                TextTruncate = Enum.TextTruncate.AtEnd,
                ZIndex = 10001,
                Parent = optBtn
            })
            
            optBtn.MouseButton1Click:Connect(function()
                if multiSelect then
                    if selectedItems[option] then
                        selectedItems[option] = nil
                        checkmark.Text = ""
                        Tween(optBtn, {BackgroundColor3 = Theme.BackgroundTertiary}, 0.1)
                    else
                        selectedItems[option] = true
                        checkmark.Text = "+"
                        Tween(optBtn, {BackgroundColor3 = Theme.AccentDark}, 0.1)
                    end
                else
                    for _, btn in ipairs(optionButtons) do
                        local cm = btn:FindFirstChildOfClass("TextLabel")
                        if cm then cm.Text = "" end
                        Tween(btn, {BackgroundColor3 = Theme.BackgroundTertiary}, 0.1)
                    end
                    selectedItems = {[option] = true}
                    checkmark.Text = "+"
                    Tween(optBtn, {BackgroundColor3 = Theme.AccentDark}, 0.1)
                end
                
                if callback then
                    local selected: {string} = {}
                    for k, v in pairs(selectedItems) do
                        if v then table.insert(selected, k) end
                    end
                    callback(selected)
                end
            end)
            
            optBtn.MouseEnter:Connect(function()
                if not selectedItems[option] then
                    Tween(optBtn, {BackgroundColor3 = Theme.BorderLight}, 0.1)
                end
            end)
            
            optBtn.MouseLeave:Connect(function()
                if not selectedItems[option] then
                    Tween(optBtn, {BackgroundColor3 = Theme.BackgroundTertiary}, 0.1)
                end
            end)
            
            table.insert(optionButtons, optBtn)
        end
    end
    
    local function UpdateDropdownPosition()
        if not dropdownList or not container or not isOpen then return end
        
        local containerAbsPos = container.AbsolutePosition
        local containerAbsSize = container.AbsoluteSize
        local mainFrameAbsPos = MainFrame.AbsolutePosition
        
        local relativeX = containerAbsPos.X - mainFrameAbsPos.X
        local relativeY = containerAbsPos.Y - mainFrameAbsPos.Y + containerAbsSize.Y + 4
        
        dropdownList.Position = UDim2.new(0, relativeX, 0, relativeY)
        dropdownList.Size = UDim2.new(0, containerAbsSize.X, 0, dropdownList.Size.Y.Offset)
    end
    
    local function ToggleDropdown()
        isOpen = not isOpen
        
        if isOpen then
            dropdownList.Visible = true
            
            if not positionTracker then
                positionTracker = TrackConnection(RunService.RenderStepped:Connect(UpdateDropdownPosition))
            end
            
            local containerAbsPos = container.AbsolutePosition
            local containerAbsSize = container.AbsoluteSize
            local mainFrameAbsPos = MainFrame.AbsolutePosition
            
            local relativeX = containerAbsPos.X - mainFrameAbsPos.X
            local relativeY = containerAbsPos.Y - mainFrameAbsPos.Y + containerAbsSize.Y + 4
            
            dropdownList.Position = UDim2.new(0, relativeX, 0, relativeY)
            dropdownList.Size = UDim2.new(0, containerAbsSize.X, 0, 0)
            
            local contentHeight = #optionButtons * (IsMobile and 30 or 34) + 8
            local targetHeight = math.min(contentHeight, IsMobile and 200 or 300)
            
            Tween(dropdownList, {Size = UDim2.new(0, containerAbsSize.X, 0, targetHeight)}, 0.2, Enum.EasingStyle.Back)
            Tween(arrowLabel, {Rotation = 180}, 0.2)
        else
            local currentWidth = dropdownList.Size.X.Offset
            Tween(dropdownList, {Size = UDim2.new(0, currentWidth, 0, 0)}, 0.15)
            Tween(arrowLabel, {Rotation = 0}, 0.15)
            
            task.delay(0.15, function()
                if not isOpen and dropdownList then
                    dropdownList.Visible = false
                end
                if positionTracker and not isOpen then
                    positionTracker:Disconnect()
                    positionTracker = nil
                end
            end)
        end
    end
    
    container.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            ToggleDropdown()
        end
    end)
    
    container.MouseEnter:Connect(function()
        Tween(container, {BackgroundColor3 = Theme.BorderLight}, 0.15)
    end)
    
    container.MouseLeave:Connect(function()
        Tween(container, {BackgroundColor3 = Theme.BackgroundTertiary}, 0.15)
    end)
    
    if options and #options > 0 then
        UpdateOptions(options)
    end
    
    return {
        Container = container,
        UpdateOptions = UpdateOptions,
        GetSelected = function()
            local selected: {string} = {}
            for k, v in pairs(selectedItems) do
                if v then table.insert(selected, k) end
            end
            return selected
        end,
    }
end

local function CreateSlider(parent: Instance, text: string, min: number, max: number, default: number, order: number?, callback: ((number) -> ())?): {Container: Frame, GetValue: () -> number, SetValue: (number) -> ()}
    local container = CreateInstance("Frame", {
        Name = text .. "Slider",
        Size = UDim2.new(1, 0, 0, IsMobile and 48 or 55),
        BackgroundColor3 = Theme.BackgroundTertiary,
        BackgroundTransparency = Theme.ButtonTransparency,
        BorderSizePixel = 0,
        LayoutOrder = order or 0,
        Parent = parent
    }) :: Frame
    AddCorner(container, 8)
    
    CreateInstance("TextLabel", {
        Size = UDim2.new(0.6, 0, 0, IsMobile and 20 or 25),
        Position = UDim2.new(0, 10, 0, 4),
        BackgroundTransparency = 1,
        Text = text,
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 10 or 13,
        Font = Enum.Font.GothamMedium,
        TextXAlignment = Enum.TextXAlignment.Left,
        TextTruncate = Enum.TextTruncate.AtEnd,
        Parent = container
    })
    
    local valueLabel = CreateInstance("TextLabel", {
        Size = UDim2.new(0.4, -12, 0, IsMobile and 20 or 25),
        Position = UDim2.new(0.6, 0, 0, 4),
        BackgroundTransparency = 1,
        Text = tostring(default),
        TextColor3 = Theme.Accent,
        TextSize = IsMobile and 10 or 13,
        Font = Enum.Font.GothamBold,
        TextXAlignment = Enum.TextXAlignment.Right,
        Parent = container
    }) :: TextLabel
    
    local sliderBg = CreateInstance("Frame", {
        Size = UDim2.new(1, -20, 0, IsMobile and 6 or 8),
        Position = UDim2.new(0, 10, 0, IsMobile and 30 or 35),
        BackgroundColor3 = Theme.Border,
        BorderSizePixel = 0,
        Parent = container
    }) :: Frame
    AddCorner(sliderBg, 4)
    
    local sliderFill = CreateInstance("Frame", {
        Size = UDim2.new((default - min) / (max - min), 0, 1, 0),
        BackgroundColor3 = Theme.Accent,
        BorderSizePixel = 0,
        Parent = sliderBg
    }) :: Frame
    AddCorner(sliderFill, 4)
    
    local sliderKnob = CreateInstance("Frame", {
        Size = UDim2.new(0, IsMobile and 14 or 16, 0, IsMobile and 14 or 16),
        Position = UDim2.new((default - min) / (max - min), IsMobile and -7 or -8, 0.5, IsMobile and -7 or -8),
        BackgroundColor3 = Theme.TextPrimary,
        BorderSizePixel = 0,
        Parent = sliderBg
    }) :: Frame
    AddCorner(sliderKnob, 8)
    AddStroke(sliderKnob, Theme.Accent, 2)
    
    local currentValue = default
    local isDragging = false
    
    local function UpdateSlider(value: number)
        currentValue = math.clamp(math.floor(value), min, max)
        local percent = (currentValue - min) / (max - min)
        sliderFill.Size = UDim2.new(percent, 0, 1, 0)
        sliderKnob.Position = UDim2.new(percent, IsMobile and -7 or -8, 0.5, IsMobile and -7 or -8)
        valueLabel.Text = tostring(currentValue)
        if callback then callback(currentValue) end
    end
    
    local function HandleInput(inputX: number)
        local percent = math.clamp((inputX - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
        UpdateSlider(min + (max - min) * percent)
    end
    
    sliderBg.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
            HandleInput(input.Position.X)
        end
    end)
    
    sliderKnob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
        end
    end)
    
    TrackConnection(UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = false
        end
    end))
    
    TrackConnection(UserInputService.InputChanged:Connect(function(input)
        if isDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            HandleInput(input.Position.X)
        end
    end))
    
    return {
        Container = container,
        GetValue = function() return currentValue end,
        SetValue = UpdateSlider
    }
end

local function CreateButton(parent: Instance, text: string, order: number?, callback: (() -> ())?): TextButton
    local button = CreateInstance("TextButton", {
        Name = text .. "Button",
        Size = UDim2.new(1, 0, 0, IsMobile and 32 or 35),
        BackgroundColor3 = Theme.Accent,
        BackgroundTransparency = Theme.ButtonTransparency,
        Text = text,
        TextColor3 = Theme.TextPrimary,
        TextSize = IsMobile and 11 or 13,
        Font = Enum.Font.GothamBold,
        BorderSizePixel = 0,
        LayoutOrder = order or 0,
        Parent = parent
    }) :: TextButton
    AddCorner(button, 8)
    
    button.MouseButton1Click:Connect(function()
        if callback then callback() end
    end)
    
    button.MouseEnter:Connect(function()
        Tween(button, {BackgroundColor3 = Theme.AccentLight}, 0.15)
    end)
    button.MouseLeave:Connect(function()
        Tween(button, {BackgroundColor3 = Theme.Accent}, 0.15)
    end)
    
    return button
end

--// ============================================================
--// POPULATE UI PAGES
--// ============================================================

-- AUTO PAGE
local AutoPage = CategoryPages["Auto"]

CreateSection(AutoPage, "Mining", 1)

local AutoMineToggle = CreateToggle(AutoPage, "Auto Mine Ores", Icons.Mine, 2, function(enabled)
    if enabled then
        StartAutoMine()
    else
        StopAutoMine()
    end
end)

CreateToggle(AutoPage, "Kill Nearby Enemy", Icons.Kill, 3, function(enabled)
    Config.KillNearbyEnabled = enabled
    if enabled then
        ShowToast(string.format("Kill Nearby: ON (Range: %d)", Config.KillNearbyRange), "success")
        -- Start system if already mining
        if State.isAutoMining then
            KillNearbySystem:Start()
        end
    else
        ShowToast("Kill Nearby: OFF", "info")
        KillNearbySystem:Stop()
    end
end)

CreateSlider(AutoPage, "Kill Range", 1, 100, 30, 4, function(value)
    Config.KillNearbyRange = value
end)

CreateButton(AutoPage, "Open Ore Manager", 5, function()
    OreManagerUI:Open()
end)

CreateSection(AutoPage, "Combat", 6)

local AutoKillToggle = CreateToggle(AutoPage, "Auto Kill Monsters", Icons.Kill, 7, function(enabled)
    if enabled then
        StartAutoKill()
    else
        StopAutoKill()
    end
end)

CreateButton(AutoPage, "Open Monster Manager", 8, function()
    MonsterManagerUI:Open()
end)

CreateSection(AutoPage, "Safety", 9)

CreateToggle(AutoPage, "Avoid Players", Icons.ESP, 10, function(enabled)
    Config.AvoidPlayerEnabled = enabled
    ShowToast(enabled and "Avoid: ON" or "Avoid: OFF", enabled and "success" or "info")
end)

-- ESP PAGE
local EspPage = CategoryPages["ESP"]

CreateSection(EspPage, "Entity ESP", 1)

CreateToggle(EspPage, "ESP Players", Icons.ESP, 2, function(enabled)
    Config.EspPlayersEnabled = enabled
end)

CreateToggle(EspPage, "ESP Monsters", Icons.Kill, 3, function(enabled)
    Config.EspMonstersEnabled = enabled
end)

CreateToggle(EspPage, "ESP Ores", Icons.Mine, 4, function(enabled)
    Config.EspOresEnabled = enabled
end)

-- MISC PAGE
local MiscPage = CategoryPages["Misc"]

CreateSection(MiscPage, "Movement", 1)

CreateToggle(MiscPage, "Custom WalkSpeed", Icons.Auto, 2, function(enabled)
    Config.WalkSpeedEnabled = enabled
    if enabled then
        SetWalkSpeed(Config.CustomWalkSpeed)
    else
        SetWalkSpeed(16)
    end
end)

CreateSection(MiscPage, "Visual", 3)

CreateToggle(MiscPage, "Fullbright", Icons.ESP, 4, function(enabled)
    Config.FullbrightEnabled = enabled
    if enabled then
        EnableFullbright()
    else
        DisableFullbright()
    end
end)

CreateSection(MiscPage, "Auto", 5)

CreateToggle(MiscPage, "Auto Run", Icons.Auto, 6, function(enabled)
    Config.AutoRunEnabled = enabled
end)

-- SETTINGS PAGE
local SettingsPage = CategoryPages["Settings"]

CreateSection(SettingsPage, "Mining Settings", 1)

CreateSlider(SettingsPage, "Mine Distance", 1, 10, 4, 2, function(value)
    Config.MineDistance = value
end)

CreateSlider(SettingsPage, "Cruise Height", 50, 300, 150, 3, function(value)
    Config.CruiseHeight = value
    CruiseSystem.cruiseHeight = value
end)

CreateSlider(SettingsPage, "Farm Speed", 10, 200, 75, 4, function(value)
    Config.MoveSpeed = value
end)

CreateSection(SettingsPage, "Auto Sell (1s Loop)", 5)

CreateToggle(SettingsPage, "Auto Sell", Icons.Auto, 6, function(enabled)
    Config.AutoSellEnabled = enabled
    if enabled then
        AutoSellSystem:Start()
    else
        AutoSellSystem:Stop()
    end
end)

CreateSlider(SettingsPage, "Sell Interval", 1, 10, 1, 7, function(value)
    Config.AutoSellInterval = value
end)

-- MANAGER BUTTONS
CreateSection(SettingsPage, "Managers", 8)

CreateButton(SettingsPage, "Open Sell Manager", 9, function()
    SellManagerUI:Open()
end)

CreateButton(SettingsPage, "Open Ore Manager", 10, function()
    OreManagerUI:Open()
end)

CreateButton(SettingsPage, "Open Monster Manager", 11, function()
    MonsterManagerUI:Open()
end)

CreateSection(SettingsPage, "Player Avoid", 12)

CreateSlider(SettingsPage, "Avoid Distance", 50, 300, 100, 13, function(value)
    Config.AvoidPlayerDistance = value
end)

CreateSection(SettingsPage, "ESP Settings", 14)

CreateSlider(SettingsPage, "ESP Distance", 100, 1000, 500, 15, function(value)
    Config.EspDistance = value
end)

CreateSection(SettingsPage, "Movement", 16)

CreateSlider(SettingsPage, "WalkSpeed", 16, 200, 16, 17, function(value)
    Config.CustomWalkSpeed = value
    if Config.WalkSpeedEnabled then SetWalkSpeed(value) end
end)

CreateSection(SettingsPage, "Combat", 18)

CreateSlider(SettingsPage, "Kill Distance", 1, 10, 7, 19, function(value)
    Config.KillDistance = value
end)

--// ============================================================
--// WINDOW CONTROLS
--// ============================================================

local dragging = false
local dragStart: Vector3? = nil
local startPos: UDim2? = nil

TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
    end
end)

TitleBar.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

TrackConnection(UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        if dragStart and startPos then
            local delta = input.Position - dragStart
            MainFrame.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end
end))

CloseButton.MouseEnter:Connect(function()
    Tween(CloseButton, {BackgroundColor3 = Color3.fromRGB(255, 100, 100)}, 0.15)
end)
CloseButton.MouseLeave:Connect(function()
    Tween(CloseButton, {BackgroundColor3 = Theme.Error}, 0.15)
end)

MinimizeButton.MouseEnter:Connect(function()
    Tween(MinimizeButton, {BackgroundColor3 = Color3.fromRGB(255, 200, 50)}, 0.15)
end)
MinimizeButton.MouseLeave:Connect(function()
    Tween(MinimizeButton, {BackgroundColor3 = Theme.Warning}, 0.15)
end)

--// ============================================================
--// CLOSE FUNCTIONALITY (FIXED - DISABLES ALL FEATURES)
--// ============================================================

local function CleanupAndClose()
    -- Set closing state FIRST
    State.isClosing = true
    
    ShowToast("Closing & disabling all...", "warning")
    
    -- DISABLE ALL FEATURES BEFORE CLOSING
    -- 1. Stop all farming
    if State.isAutoMining then
        State.isAutoMining = false
        FarmSystem:Stop()
    end
    
    if State.isAutoKilling then
        State.isAutoKilling = false
        FarmSystem:Stop()
    end
    
    -- 2. Stop auto sell
    Config.AutoSellEnabled = false
    AutoSellSystem:Stop()
    LiveToast:Destroy()
    
    -- 3. Stop ESP
    Config.EspPlayersEnabled = false
    Config.EspMonstersEnabled = false
    Config.EspOresEnabled = false
    EspSystem:Stop()
    
    -- 4. Disable misc features
    Config.AutoRunEnabled = false
    Config.WalkSpeedEnabled = false
    Config.AvoidPlayerEnabled = false
    
    -- 5. Disable fullbright
    if Config.FullbrightEnabled then
        Config.FullbrightEnabled = false
        DisableFullbright()
    end
    
    -- 6. Cleanup movement controller
    MovementController:Cleanup()
    
    -- 7. Cleanup all connections
    for _, conn in ipairs(Connections) do
        pcall(function() conn:Disconnect() end)
    end
    table.clear(Connections)
    
    -- 8. Restore character
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = StoredHumanoidValues.WalkSpeed
            humanoid.JumpPower = StoredHumanoidValues.JumpPower
            humanoid.JumpHeight = StoredHumanoidValues.JumpHeight
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
        
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    
    -- 9. Animate close
    Tween(MainFrame, {
        Size = UDim2.new(0, 0, 0, 0),
        Position = UDim2.new(0.5, 0, 0.5, 0)
    }, 0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)
    
    Tween(ToggleButton, {
        Size = UDim2.new(0, 0, 0, 0)
    }, 0.3)
    
    Tween(Shadow, {ImageTransparency = 1}, 0.2)
    
    -- 10. Destroy GUI after animation
    task.delay(0.35, function()
        if ScreenGui then ScreenGui:Destroy() end
    end)
end

CloseButton.MouseButton1Click:Connect(CleanupAndClose)

-- Minimize functionality
local isMinimized = false

MinimizeButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    
    if isMinimized then
        Tween(MainFrame, {Size = MainFrameMinimizedSize}, 0.3)
        Sidebar.Visible = false
        ContentArea.Visible = false
    else
        Tween(MainFrame, {Size = MainFrameSize}, 0.3)
        task.delay(0.2, function()
            Sidebar.Visible = true
            ContentArea.Visible = true
        end)
    end
end)

--// ============================================================
--// OPEN ANIMATION
--// ============================================================

MainFrame.Size = UDim2.new(0, 0, 0, 0)
MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
Shadow.ImageTransparency = 1
ToggleButton.Size = UDim2.new(0, 0, 0, 0)

Tween(MainFrame, {
    Size = MainFrameSize,
    Position = UDim2.new(0.5, -MainFrameSize.X.Offset/2, 0.5, -MainFrameSize.Y.Offset/2)
}, 0.5, Enum.EasingStyle.Back)

Tween(Shadow, {ImageTransparency = 0.5}, 0.8)

Tween(ToggleButton, {Size = ToggleButtonSize}, 0.5, Enum.EasingStyle.Back)

task.delay(0.6, function()
    ShowToast("Glad Hub V7.7 Loaded!", "success", 4)
    ShowToast("Managers: Settings > Managers", "info", 4)
    if IsMobile then
        ShowToast("Tap icon to toggle UI", "info", 4)
    end
end)

--// ============================================================
--// DEBUG
--// ============================================================

_G.GladHubDebug = {
    Config = Config,
    State = State,
    MovementController = MovementController,
    FarmSystem = FarmSystem,
    AutoSellSystem = AutoSellSystem,
    EspSystem = EspSystem,
    CruiseSystem = CruiseSystem,
    LiveToast = LiveToast,
    SellManagerUI = SellManagerUI,
    
    -- Ore data
    OreDatabase = OreDatabase,
    SellSelection = SellSelection,
    DefaultProtectedOres = DefaultProtectedOres,
    
    -- Test functions
    SellNow = function()
        local items = GetStashItems()
        local success, err, qty = SellItems(items)
        return success, err, qty, items
    end,
    GetStashItems = GetStashItems,
    SanitizeBasket = SanitizeBasket,
    ShouldSkipItem = ShouldSkipItem,
    ShouldSellOre = ShouldSellOre,
    IsDefaultProtected = IsDefaultProtected,
    IsMobile = IsMobile,
    
    -- Sell Manager controls
    OpenSellManager = function()
        SellManagerUI:Open()
    end,
    GetEnabledOres = function()
        local enabled = {}
        for name, val in pairs(SellSelection) do
            if val then table.insert(enabled, name) end
        end
        return enabled
    end,
    GetDisabledOres = function()
        local disabled = {}
        for name, val in pairs(SellSelection) do
            if not val then table.insert(disabled, name) end
        end
        return disabled
    end,
    
    -- Ore Manager controls
    OpenOreManager = function()
        OreManagerUI:Open()
    end,
    OreFarmSelection = OreFarmSelection,
    
    -- Monster Manager controls
    OpenMonsterManager = function()
        MonsterManagerUI:Open()
    end,
    MonsterFarmSelection = MonsterFarmSelection,
    MonsterDatabase = MonsterDatabase,
    
    -- DEBUG: Print detailed stash info
    PrintStashDebug = function()
        print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print("  STASH DEBUG INFO")
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        
        local background, err = GetStashBackground()
        if not background then
            print("âŒ Cannot access stash:", err or "unknown error")
            
            -- Try to find alternative paths
            print("\nðŸ” Searching for stash UI...")
            local pGui = player:FindFirstChild("PlayerGui")
            if pGui then
                for _, gui in ipairs(pGui:GetChildren()) do
                    print("  GUI:", gui.Name)
                    if gui.Name:lower():find("stash") or gui.Name:lower():find("menu") or gui.Name:lower():find("inventory") then
                        print("    ^ POTENTIAL MATCH")
                        for _, child in ipairs(gui:GetDescendants()) do
                            if child.Name:lower():find("background") or child.Name:lower():find("content") or child.Name:lower():find("items") then
                                print("      Found:", child:GetFullName())
                            end
                        end
                    end
                end
            end
            return
        end
        
        print("âœ“ Stash Background found:", background:GetFullName())
        print("\nðŸ“¦ Raw Children in Stash:")
        
        local childCount = 0
        for _, child in ipairs(background:GetChildren()) do
            childCount += 1
            if childCount <= 15 then -- Limit output
                print(string.format("  [%d] Name='%s' Class=%s", childCount, child.Name, child.ClassName))
                
                -- Show first-level children of each item
                local subChildren = {}
                for _, sub in ipairs(child:GetChildren()) do
                    table.insert(subChildren, sub.Name .. "(" .. sub.ClassName .. ")")
                end
                if #subChildren > 0 then
                    print("      Children:", table.concat(subChildren, ", "))
                end
            end
        end
        if childCount > 15 then
            print("  ... and", childCount - 15, "more children")
        end
        
        print("\nðŸ” Parsed Items:")
        local items = GetStashItems()
        local count = 0
        for name, qty in pairs(items) do
            count += 1
            local willSell = not ShouldSkipItem(name)
            local selectionState = SellSelection[name]
            print(string.format("  %s x%d | WillSell=%s | Selection=%s", 
                name, qty, 
                tostring(willSell), 
                selectionState == nil and "nil" or tostring(selectionState)
            ))
        end
        
        if count == 0 then
            print("  (No items found)")
        end
        
        print("\nðŸ“¤ Sanitized Basket (what will actually be sent):")
        local sanitized = SanitizeBasket(items)
        local sanitizedCount = 0
        for name, qty in pairs(sanitized) do
            sanitizedCount += 1
            print(string.format("  %s = %d", name, qty))
        end
        
        if sanitizedCount == 0 then
            print("  (Empty - nothing will be sold)")
        end
        
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
        return items, sanitized
    end,
    
    -- Direct test with exact working format
    TestSellDirect = function(itemName, quantity)
        itemName = itemName or "Stone"
        quantity = quantity or 1
        
        print("\n[TEST] Direct sell test:")
        print("  Item:", itemName, "x", quantity)
        
        local args = {
            "SellConfirm",
            {
                Basket = {
                    [itemName] = quantity
                }
            }
        }
        
        -- DIRECT CALL - ONE LINE!
        local result = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("DialogueService"):WaitForChild("RF"):WaitForChild("RunCommand"):InvokeServer(unpack(args))
        
        print("  Result:", result)
        return true, result
    end,
    
    -- Death Respawn System
    DeathRespawnSystem = DeathRespawnSystem,
    RespawnWaypoints = RespawnWaypoints,
    TestRespawnNav = function()
        print("Testing respawn navigation...")
        task.spawn(NavigateAfterRespawn)
    end,
    
    -- Debug: Scan all ores in Rocks folder
    ScanOres = function()
        print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print("  SCANNING ROCKS FOLDER")
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        
        local rocksFolder = Workspace:FindFirstChild("Rocks")
        if not rocksFolder then
            print("âŒ Rocks folder NOT FOUND!")
            return
        end
        
        print("âœ… Rocks folder found:", rocksFolder:GetFullName())
        print("  My name:", player.Name)
        
        local oreCount = 0
        local mineable = 0
        local oreTypes = {}
        
        for _, child1 in ipairs(rocksFolder:GetChildren()) do
            for _, child2 in ipairs(child1:GetChildren()) do
                for _, ore in ipairs(child2:GetChildren()) do
                    if ore:IsA("Model") or ore:IsA("BasePart") then
                        oreCount += 1
                        local health = ore:GetAttribute("Health") or "nil"
                        local lastHit = ore:GetAttribute("LastHitPlayer") or ""
                        local canMine = CanMineRock(ore)
                        
                        oreTypes[ore.Name] = (oreTypes[ore.Name] or 0) + 1
                        if canMine then mineable += 1 end
                        
                        if oreCount <= 10 then
                            local status = canMine and "âœ…" or "âŒ"
                            print(string.format("  %s %s HP:%s LastHit:%s", 
                                status, ore.Name, tostring(health), 
                                lastHit == "" and "none" or lastHit))
                        end
                    end
                end
            end
        end
        
        print("\n  Total ores:", oreCount)
        print("  Mineable:", mineable)
        print("  Ore types found:")
        for name, count in pairs(oreTypes) do
            print("    -", name, "x", count)
        end
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
        
        return oreCount, oreTypes
    end,
    
    -- Debug: Find nearest ore
    TestFindOre = function()
        local ore, dist = FindNearestOre(true)
        if ore then
            local lastHit = ore:GetAttribute("LastHitPlayer") or "none"
            print("Found ore:", ore.Name)
            print("  Distance:", math.floor(dist))
            print("  HP:", ore:GetAttribute("Health"), "/", ore:GetAttribute("MaxHealth"))
            print("  LastHitPlayer:", lastHit)
            print("  CanMine:", CanMineRock(ore))
            return ore
        else
            print("No mineable ore found!")
            return nil
        end
    end,
    
    -- Debug: Check CanMineRock
    CanMineRock = CanMineRock,
    
    -- Rock Priority
    RockPriority = RockPriority,
    GetRockPriority = GetRockPriority,
    
    -- Smart Rock Type Blacklist
    BlacklistedRockTypes = BlacklistedRockTypes,
    IsRockTypeBlacklisted = IsRockTypeBlacklisted,
    BlacklistRockType = BlacklistRockType,
    ClearRockTypeBlacklist = ClearRockTypeBlacklist,
    
    -- Kill Nearby System
    KillNearbySystem = KillNearbySystem,
    FindNearbyEnemy = FindNearbyEnemy,
    
    -- Show current blacklist
    ShowBlacklist = function()
        print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print("  BLACKLISTED ROCK TYPES")
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        local count = 0
        for name, _ in pairs(BlacklistedRockTypes) do
            print("  âŒ", name)
            count += 1
        end
        if count == 0 then
            print("  (none)")
        end
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
    end,
}

print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("  Glad Hub | The Forge | V7.7")
print("     SMART FARMING EDITION")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("  + SMART BLACKLIST: Can't mine? â†’ Lower tier")
print("  + KILL NEARBY: Auto-kill enemies while mining")
print("  + Target-Only Mining (mines selected rocks)")
print("  + LastHitPlayer check (skip others' rocks)")
print("  Device:", IsMobile and "MOBILE" or "PC")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("")
print("  Debug Commands:")
print("  _G.GladHubDebug.ScanOres()       -- List all ores")
print("  _G.GladHubDebug.ShowBlacklist()  -- Show blacklisted types")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
